FILE: action_processor.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from game_state import GameState, GameWorld

if TYPE_CHECKING:
    from ai_manager import AIManager

class ActionProcessor:

    def process_action(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        intent = intent_data.get("intent")
        
        if intent == "take_item":
            return self._handle_take_item(game_state, world, intent_data)
        elif intent == "move":
            return self._handle_move(game_state, world, ai_manager, intent_data)
        elif intent == "pass_time":
            return self._handle_pass_time(game_state, world, intent_data)
        
        logging.warning(f"No state-changing action found for intent '{intent}'.")
        return "Automatic Success"

    def _handle_take_item(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        target_name = intent_data.get("target")
        if not target_name:
            logging.warning("AI intent 'take_item' was missing a 'target'.")
            return "Failure: The AI could not determine what item you wanted to take."

        item_to_take = game_state.find_item_in_location(target_name, world)

        if item_to_take:
            game_state.move_item_from_location_to_player(item_to_take, world)
            logging.info(f"Player took '{item_to_take.name}'. State updated.")
            return "Success"
        else:
            logging.info(f"Player tried to take '{target_name}', but it was not found in the location.")
            return f"Failure: The '{target_name}' is not here."

    def _handle_move(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        target_id = intent_data.get("target")
        if not target_id:
            logging.warning("AI intent 'move' was missing a 'target' location ID.")
            return "Failure: The AI could not determine where you wanted to go."
        
        current_location = game_state.get_current_location(world)
        if not current_location:
            logging.error(f"Player is in a non-existent location: {game_state.current_location_id}")
            return "Failure: You are lost in the void."

        exit_description = ""
        is_valid_exit = False
        for desc, dest_id in current_location.exits.items():
            if dest_id == target_id:
                is_valid_exit = True
                exit_description = desc
                break

        if is_valid_exit:
            destination = world.get_location(target_id)
            if destination:
                game_state.current_location_id = target_id
                logging.info(f"Player moved from '{current_location.id}' to '{target_id}'. State updated.")
                return "Success"
            else:
                logging.warning(f"Exit '{exit_description}' points to a non-existent location '{target_id}'. Attempting dynamic generation.")
                
                location_data = ai_manager.generate_new_location(
                    source_location=current_location,
                    exit_description=exit_description,
                    new_location_id=target_id
                )
                
                if location_data:
                    newly_created_location = world.create_and_add_location(location_data)
                    if newly_created_location:
                        game_state.current_location_id = target_id
                        logging.info(f"Dynamically created and moved player to '{target_id}'.")
                        return "Success"
                    else:
                        logging.error(f"AI generated data for '{target_id}', but it was invalid and could not be added to the world.")
                        return "Failure: The way is blocked by a shimmer of unreality."
                else:
                    logging.error(f"AI failed to generate data for new location '{target_id}'.")
                    return "Failure: The way is blocked by mysterious forces."
        else:
            logging.info(f"Player tried to move to invalid destination '{target_id}' from '{current_location.id}'.")
            return "Failure: You can't seem to find a way to do that."
    
    def _handle_pass_time(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        duration = intent_data.get("duration")
        if not isinstance(duration, int) or duration <= 0:
            logging.warning(f"AI intent 'pass_time' had invalid duration: {duration}.")
            return "Failure: The AI could not determine how long you wanted to wait."
        
        game_state.minutes_elapsed += duration
        logging.info(f"Player passed time by {duration} minutes. New time: {game_state.minutes_elapsed}")
        return "Success"

FILE: ai_manager.py
import json
import logging
from typing import Optional, Dict, Any

from config import OLLAMA_ENABLED, USE_GEMINI_API
from prompts import (
    MECHANICS_PROMPT,
    NARRATION_PROMPT,
    LOCATION_GENERATION_PROMPT,
    NPC_STATE_UPDATE_PROMPT,
    WORLD_EVENT_PROMPT,
    DIALOGUE_GENERATION_PROMPT,
    QUEST_GENERATION_PROMPT
)
from prompts.decomposition import (
    GET_INTENT_PROMPT,
    GET_TARGET_PROMPT,
    GET_DIALOGUE_TOPIC_PROMPT,
    GET_RECIPIENT_PROMPT,
    GET_TARGET_ON_PROMPT,
    GET_ACTION_DESCRIPTION_PROMPT,
    GET_MOVE_DESTINATION_PROMPT,
    GET_QUEST_ACTION_TYPE_PROMPT
)
from game_state import GameState, GameWorld, Location, Character
from ai_providers.gemini_client import GeminiClient
from ai_providers.ollama_client import OllamaClient
from ai_parser import AIParser

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class AIManager:

    def __init__(self):
        self.gemini_client = GeminiClient() if USE_GEMINI_API else None
        self.ollama_client = OllamaClient() if OLLAMA_ENABLED else None
        self.parser = AIParser()

        if not self.ollama_client:
            raise RuntimeError("Ollama is not enabled, but is required as the default provider.")

        logging.info("AIManager initialized. Default provider: Ollama. Gemini is available for specialized tasks.")

    def _generate_content(self, prompt: str, expect_json: bool) -> Optional[str]:
        # Guard Clause to satisfy Pylance and prevent runtime errors.
        if not self.ollama_client:
            logging.critical("Ollama client is not available to generate content.")
            return None
            
        return self.ollama_client.generate_content(prompt, force_json=expect_json)

    def _execute_prompt(self, prompt: str, expect_json: bool = True) -> Optional[Dict[str, Any] | str]:
        raw_text = self._generate_content(prompt, expect_json=expect_json)
        if raw_text is None:
            return None

        logging.info(f"Received raw response from AI provider: {raw_text.strip()}")

        if expect_json:
            return self.parser.find_and_parse_json(raw_text)
        else:
            return self.parser.parse_simple_response(raw_text)

    def _get_simple_response(self, prompt: str) -> Optional[str]:
        response = self._execute_prompt(prompt, expect_json=False)
        if isinstance(response, str):
            return response
        return None

    def get_player_intent(self, game_state: GameState, world: GameWorld, user_input: str) -> Optional[Dict[str, Any]]:
        logging.info("--- Starting Intent Assembly Line ---")

        logging.info("Station 1: Classifying Intent...")
        intent_prompt = GET_INTENT_PROMPT.format(user_input=user_input)
        intent = self._get_simple_response(intent_prompt)
        if not intent:
            logging.error("Assembly line failed at Station 1: Could not determine intent.")
            return None
        logging.info(f"-> Determined Intent: '{intent}'")

        logging.info("Station 2: Identifying Target...")
        current_loc = game_state.get_current_location(world)
        character_names = [c.name for c in current_loc.characters] if current_loc else []
        item_names = [i.name for i in current_loc.items] if current_loc else []
        interactable_names = [i.name for i in current_loc.interactables] if current_loc else []
        exit_descriptions = list(current_loc.exits.keys()) if current_loc else []
        
        target_prompt = GET_TARGET_PROMPT.format(
            user_input=user_input,
            character_names=character_names,
            item_names=item_names,
            interactable_names=interactable_names,
            exit_descriptions=exit_descriptions
        )
        target = self._get_simple_response(target_prompt)
        logging.info(f"-> Determined Target: '{target}'")

        if intent == "move":
            logging.info("Special Station 'move': Determining Destination ID...")
            move_prompt = GET_MOVE_DESTINATION_PROMPT.format(
                user_input=user_input,
                exits_json=json.dumps(current_loc.exits, indent=2) if current_loc else "{}"
            )
            destination_id = self._get_simple_response(move_prompt)
            if destination_id and destination_id in (current_loc.exits.values() if current_loc else []):
                target = destination_id
                logging.info(f"-> Overrode target with Destination ID: '{target}'")
            else:
                logging.warning(f"Could not reliably determine destination ID for move. Sticking with general target: '{target}'")

        logging.info("Station 3: Extracting Additional Parameters...")
        parameters = {}
        if intent == "dialogue":
            topic_prompt = GET_DIALOGUE_TOPIC_PROMPT.format(user_input=user_input)
            topic = self._get_simple_response(topic_prompt)
            if topic: parameters['topic'] = topic
        elif intent == "quest_action":
            action_type_prompt = GET_QUEST_ACTION_TYPE_PROMPT.format(user_input=user_input)
            action_type = self._get_simple_response(action_type_prompt)
            if action_type: parameters['action_type'] = action_type
        elif intent == "give_item":
            recipient_prompt = GET_RECIPIENT_PROMPT.format(user_input=user_input)
            recipient = self._get_simple_response(recipient_prompt)
            if recipient: parameters['recipient'] = recipient
        elif intent == "use_item":
            target_on_prompt = GET_TARGET_ON_PROMPT.format(user_input=user_input)
            target_on = self._get_simple_response(target_on_prompt)
            if target_on: parameters['target_on'] = target_on
        logging.info(f"-> Found Parameters: {parameters}")
        
        logging.info("Foreman: Assembling Final Intent Data...")
        action_desc_prompt = GET_ACTION_DESCRIPTION_PROMPT.format(
            user_input=user_input,
            intent=intent,
            target=target
        )
        action_description = self._get_simple_response(action_desc_prompt) or f"Player action: {user_input}"

        intent_data = {
            "intent": intent,
            "target": target,
            "action_description": action_description
        }
        intent_data.update(parameters)
        intent_data = {k: v for k, v in intent_data.items() if v is not None}
        
        logging.info(f"--- Assembly Line Complete. Final Data: {intent_data} ---")
        return intent_data

    def determine_skill_check_details(self, game_state: GameState, world: GameWorld, action_description: str) -> Optional[Dict[str, Any]]:
        logging.info(f"Phase 2: Determining mechanics for action: '{action_description}'")
        context_str = game_state.get_context_string(world)
        prompt = f"{MECHANICS_PROMPT}\n\nHere is the current game state for context:\n{context_str}\n\nHere is the player's described action:\n\"{action_description}\""
        result = self._execute_prompt(prompt, expect_json=True)
        if isinstance(result, dict):
            return result
        return None

    def generate_quest_from_context(self, quest_giver: Character, offer_memory: str) -> Optional[Dict[str, Any]]:
        logging.info(f"Generating quest from NPC '{quest_giver.name}' based on memory: '{offer_memory}'.")
        prompt = f"{QUEST_GENERATION_PROMPT}\n\nCONTEXT:\n- Quest Giver Name: \"{quest_giver.name}\"\n- The quest giver's memory of the offer: \"{offer_memory}\""
        result = self._execute_prompt(prompt, expect_json=True)
        if isinstance(result, dict):
            logging.info(f"Successfully generated JSON data for new quest from '{quest_giver.name}'.")
            return result
        logging.error(f"Failed to generate valid JSON for quest from '{quest_giver.name}'.")
        return None

    def generate_new_location(self, source_location: Location, exit_description: str, new_location_id: str) -> Optional[Dict[str, Any]]:
        logging.info(f"Dynamically generating new location '{new_location_id}' from source '{source_location.id}'.")
        prompt = f"{LOCATION_GENERATION_PROMPT}\n\nHere is the context for the new location to generate:\n- The player is coming from a location named: \"{source_location.name}\" (ID: {source_location.id})\n- The exit they used was described as: \"{exit_description}\"\n- The required unique ID for this new location must be: \"{new_location_id}\""
        result = self._execute_prompt(prompt, expect_json=True)
        if isinstance(result, dict):
            logging.info(f"Successfully generated JSON data for new location '{new_location_id}'.")
            return result
        logging.error(f"Failed to generate valid JSON for new location '{new_location_id}'.")
        return None

    def narrate_outcome(self, game_state: GameState, world: GameWorld, action_description: str, result: str) -> str:
        logging.info(f"Phase 3: Narrating outcome for result: '{result}'")
        context_str = game_state.get_context_string(world)
        prompt = f"{NARRATION_PROMPT}\n\nHere is the current game state for context:\n{context_str}\n\nHere is what the player tried to do:\n\"{action_description}\"\n\nHere is the result of their attempt: {result}"
        narration = self._execute_prompt(prompt, expect_json=False)
        if isinstance(narration, str) and narration:
            return narration
        return "The world seems to pause for a moment, unsure how to react. Perhaps try something else?"

    def generate_dialogue_response(self, game_state: GameState, world: GameWorld, npc: Character, topic: str) -> Optional[str]:
        logging.info(f"Generating dialogue for NPC '{npc.name}' on topic: '{topic}'")
        context_str = game_state.get_context_string(world)
        prompt = f"{DIALOGUE_GENERATION_PROMPT}\n\nCONTEXT:\n- Current Game State: {context_str}\n- NPC being spoken to: {json.dumps(npc.to_dict(), indent=2)}\n- Player's action/topic of conversation: \"{topic}\""
        narration = self._execute_prompt(prompt, expect_json=False)
        if isinstance(narration, str) and narration:
            return narration.strip('"')
        return None

    def update_npc_state(self, npc: Character, action_description: str, narration: str) -> Optional[Dict[str, Any]]:
        logging.info(f"Phase 4: Updating state for NPC '{npc.name}'.")
        npc_state_json = json.dumps(npc.to_dict(), indent=2)
        prompt = f"{NPC_STATE_UPDATE_PROMPT}\n\nCONTEXT:\n- Current NPC State: {npc_state_json}\n- Player's Action: \"{action_description}\"\n- Interaction Outcome (Narration): \"{narration}\""
        result = self._execute_prompt(prompt, expect_json=True)
        if isinstance(result, dict):
            return result
        return None

    def generate_world_event(self, game_state: GameState, world: GameWorld) -> Optional[Dict[str, Any]]:
        logging.info("Checking for a background world event...")
        context_str = game_state.get_context_string(world)
        prompt = f"{WORLD_EVENT_PROMPT}\n\nHere is the current game state for context:\n{context_str}"
        result = self._execute_prompt(prompt, expect_json=True)
        if isinstance(result, dict) and result:
            return result
        return None

FILE: ai_parser.py
import json
import logging
import re
from typing import Optional, Dict, Any

class AIParser:
    """A dedicated class for cleaning and parsing raw text output from AI models."""

    def find_and_parse_json(self, raw_text: str) -> Optional[Dict[str, Any]]:
        """
        Finds the first valid JSON object in a raw string and parses it.
        
        Args:
            raw_text: The potentially messy string from the AI.

        Returns:
            A parsed dictionary, or None if no valid JSON is found.
        """
        if not isinstance(raw_text, str):
            return None

        match = re.search(r'\{.*\}', raw_text, re.DOTALL)
        if match:
            json_string = match.group(0)
            try:
                return json.loads(json_string)
            except json.JSONDecodeError as e:
                logging.error(f"Failed to decode extracted JSON. Error: {e}. String was: '{json_string}'")
                return None
        else:
            logging.warning(f"Could not find any JSON-like structure in raw text: '{raw_text}'")
            return None

    def parse_simple_response(self, raw_text: str) -> Optional[str]:
        """
        Cleans and returns a simple, single-line text response from the AI.
        Strips common markdown and returns None if the result is empty or the word 'None'.
        
        Args:
            raw_text: The potentially messy string from the AI.

        Returns:
            A cleaned string, or None.
        """
        if not isinstance(raw_text, str):
            return None
        
        # Remove markdown code blocks and then strip specific markdown characters
        cleaned_response = raw_text.replace("```json", "").replace("```", "").strip()
        cleaned_response = cleaned_response.strip().strip('`').strip('*').strip('"').strip()

        if cleaned_response.lower() == "none" or not cleaned_response:
            return None
        
        return cleaned_response

FILE: config.py
# config.py

# --- Primary API Configuration ---
# Set to False to disable the Gemini API and use the Ollama fallback directly.
USE_GEMINI_API = False

# --- Gemini API Configuration ---
# Your Gemini key here...
GEMINI_API_KEY = "AIzaSyA0BM8H6zh-LSWootFH_Subnur7bPQk_cs"

# --- Game Configuration ---
MODEL_NAME = "gemini-1.5-flash"


# --- Ollama Fallback Configuration ---
OLLAMA_ENABLED = True
OLLAMA_BASE_URL = "http://localhost:11434"

# The name of the Ollama model to use. After testing, llama3 proved more reliable
# at understanding intent than qwen for this specific application.
OLLAMA_MODEL = "llama3:8b"

# The number of seconds to wait for a response from the Ollama API before giving up.
# We are keeping the longer timeout as it's a good general robustness improvement.
OLLAMA_TIMEOUT = 45

FILE: display_manager.py
import logging
from typing import Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from definitions.entities import Character
    from definitions.world_objects import Location
    from game_state import GameState
    from game_mechanics import calculate_stat_modifier

class DisplayManager:
    def __init__(self, line_width: int = 80):
        self.line_width = line_width

    def _print_header(self, title: str):
        print(f"\n--- {title} ".ljust(self.line_width, "-"))

    def _print_footer(self):
        print("-" * self.line_width)

    def narrate(self, text: str):
        print(f"\n{text}")

    def system_message(self, text: str):
        print(text)

    def show_error(self, text: str):
        print(f"\n[ERROR] {text}")

    def show_location(self, location: Optional['Location']):
        if not location:
            logging.error("DisplayManager cannot print location: Location object is None.")
            self.narrate("You are utterly lost in a formless void.")
            return

        print(f"\nLocation: {location.name}")
        print(location.description)
        if location.items:
            print("You see:", ", ".join(item.name for item in location.items) + ".")
        if location.characters:
            print("People here:", ", ".join(char.name for char in location.characters) + ".")
        
        if location.exits:
            print("Exits:")
            for exit_desc in location.exits.keys():
                print(f" - {exit_desc.capitalize()}")

    def show_player_character(self, player: 'Character'):
        self.system_message(f"You are {player.name}, {player.description}")

    def show_inventory(self, player: 'Character'):
        self._print_header("Inventory")
        if not player.inventory:
            print("You are carrying nothing.")
        else:
            for item in player.inventory:
                print(f" - {item.name} (Value: {item.value})")
        print(f"Coin: {player.money} copper pieces")
        self._print_footer()

    def show_character_sheet(self, player: 'Character'):
        from game_mechanics import calculate_stat_modifier
        self._print_header("Character Sheet")
        print(f"Name: {player.name}")
        print(f"HP: {player.hp} / {player.max_hp}")
        print(f"Level: {player.level} ({player.xp}/{player.xp_to_next_level} XP)")
        print(f"Armor Class: {player.get_total_armor_class()}")
        print("\nAttributes:")
        for stat, value in player.stats.items():
            modifier = calculate_stat_modifier(value)
            print(f"  - {stat.capitalize():>12}: {value} ({modifier:+.0f})")
        self._print_footer()

    def show_equipment(self, player: 'Character'):
        self._print_header("Equipped Items")
        equipped_any = False
        all_slots = ["main_hand", "off_hand", "head", "chest", "legs", "feet", "hands", "amulet", "ring"]
        for slot in all_slots:
            item = player.equipment.get(slot)
            if item:
                print(f"  - {slot.replace('_', ' ').title():>9}: {item.name}")
                equipped_any = True
        
        if not equipped_any:
            print("You have nothing equipped.")
        self._print_footer()
        
    def show_quest_journal(self, game_state: 'GameState'):
        self._print_header("Quest Journal")
        active_quests = [q for q in game_state.quest_log.values() if q.status == "active"]
        
        if not active_quests:
            print("You have no active quests.")
        else:
            for quest in active_quests:
                print(f"\n[ {quest.name} ]")
                print(f"  {quest.description}")
                for objective in quest.objectives:
                    status_marker = "[X]" if objective.is_complete else "[ ]"
                    print(f"    {status_marker} {objective.description}")
        self._print_footer()

    def show_help(self):
        self._print_header("Help Menu")
        print("This is a text adventure game where you type commands to interact with the world.")
        print("Try to phrase your actions naturally, for example: 'talk to the blacksmith' or 'attack the goblin with my sword'.")
        print("\nMeta-Commands (commands that are not part of the game world):")
        print("  - inventory (i)    : Show your inventory and money.")
        print("  - stats/character  : Display your character sheet.")
        print("  - equipment (eq)   : Show your currently equipped items.")
        print("  - quests/journal   : Display your active quests.")
        print("  - save <name>      : Save the game to a slot named <name>.")
        print("  - load <name>      : Load the game from slot <name>.")
        print("  - quit/exit        : Exit the game.")
        print("\nCommon in-game actions:")
        print("  - look / look at <thing>  : Observe your surroundings or something specific.")
        print("  - take <item>             : Pick up an item.")
        print("  - drop <item>             : Drop an item from your inventory.")
        print("  - equip <item>            : Equip an item from your inventory.")
        print("  - unequip <item>          : Unequip an item and return it to inventory.")
        print("  - talk to <person>        : Start a conversation.")
        print("  - attack <target>         : Initiate combat.")
        self._print_footer()

    def show_level_up(self, player: 'Character'):
        self.narrate(f"[Congratulations! You have reached Level {player.level}!]")
        print(f"  Max HP increased to {player.max_hp}.")
        print(f"  All your stats have increased by 1.")
        print(f"  You feel stronger.")

    def show_reputation_change(self, faction: str, change: int):
        direction = "increased" if change > 0 else "decreased"
        self.system_message(f"[Your reputation with {faction.replace('_', ' ').title()} has {direction}.]")

    def show_quest_started(self, quest_name: str, quest_description: str):
        self.narrate(f"[New Quest Started: {quest_name}]")
        print(f"  {quest_description}")
        
    def show_objective_complete(self, objective_description: str):
        self.narrate(f"[Objective Complete: {objective_description}]")

    def show_quest_complete(self, quest_name: str):
        self.narrate(f"[Quest Complete: {quest_name}]")

FILE: event_executor.py
import logging
from typing import List, Dict, Any, TYPE_CHECKING

from game_state import GameState, GameWorld, Character
from display_manager import DisplayManager

if TYPE_CHECKING:
    from ai_manager import AIManager
    from managers.npc_behavior_manager import NPCBehaviorManager
    from managers.weather_manager import WeatherManager
    from managers.companion_manager import CompanionManager

def execute_player_mutations(game_state: GameState, mutations: List[Dict[str, Any]]):
    for mutation in mutations:
        op = mutation.get("op")
        logging.info(f"Executing player mutation: {op}")
        try:
            if op == "damage_player":
                amount = mutation["amount"]
                game_state.player.hp -= amount
                logging.info(f"Player took {amount} damage. New HP: {game_state.player.hp}")
            elif op == "add_player_status":
                effect = mutation["effect"]
                if effect not in game_state.player.status_effects:
                    game_state.player.status_effects.append(effect)
                    logging.info(f"Player gained status effect: {effect}")
            elif op == "remove_player_status":
                effect = mutation["effect"]
                if effect in game_state.player.status_effects:
                    game_state.player.status_effects.remove(effect)
                    logging.info(f"Player lost status effect: {effect}")
        except (KeyError, TypeError) as e:
            logging.error(f"Invalid player mutation format for op '{op}'. Error: {e}. Mutation: {mutation}")

def execute_world_mutations(game_state: GameState, world: GameWorld, mutations: List[Dict[str, Any]]):
    for mutation in mutations:
        op = mutation.get("op")
        logging.info(f"Executing world event mutation: {op}")
        try:
            if op == "move_npc":
                char_name = mutation["character_name"]
                new_loc_id = mutation["new_location_id"]
                char_data = world.find_character_anywhere(char_name)
                new_loc = world.get_location(new_loc_id)
                if char_data and new_loc:
                    char, old_loc = char_data
                    if old_loc.id != new_loc.id:
                        old_loc.remove_character(char)
                        new_loc.add_character(char)
                        logging.info(f"Moved NPC '{char_name}' from '{old_loc.id}' to '{new_loc_id}'.")
            elif op == "add_character":
                loc_id = mutation["location_id"]
                loc = world.get_location(loc_id)
                if loc:
                    char_data = mutation["character"]
                    new_char = Character(**char_data)
                    loc.add_character(new_char)
            elif op == "remove_character":
                loc_id = mutation["location_id"]
                char_name = mutation["character_name"]
                loc = world.get_location(loc_id)
                if loc:
                    char_to_remove = next((c for c in loc.characters if c.name == char_name), None)
                    if char_to_remove:
                        loc.remove_character(char_to_remove)
                        logging.info(f"Removed NPC '{char_name}' from location '{loc_id}'.")
            elif op == "update_location_description":
                loc_id = mutation["location_id"]
                new_desc = mutation["new_description"]
                loc = world.get_location(loc_id)
                if loc:
                    loc.description = new_desc
                    logging.info(f"Updated description for location '{loc_id}'.")
            elif op == "add_exit":
                loc_id = mutation["location_id"]
                exit_desc = mutation["exit_description"]
                dest_id = mutation["destination_id"]
                loc = world.get_location(loc_id)
                if loc:
                    loc.exits[exit_desc] = dest_id
                    logging.info(f"Added exit from '{loc_id}' to '{dest_id}'.")
            elif op == "remove_exit":
                loc_id = mutation["location_id"]
                exit_desc = mutation["exit_description"]
                loc = world.get_location(loc_id)
                if loc and exit_desc in loc.exits:
                    del loc.exits[exit_desc]
                    logging.info(f"Removed exit '{exit_desc}' from location '{loc_id}'.")

        except (KeyError, TypeError) as e:
            logging.error(f"Invalid world mutation format for op '{op}'. Error: {e}. Mutation: {mutation}")

def execute_npc_schedules(game_state: GameState, world: GameWorld):
    current_hour = (game_state.minutes_elapsed // 60) % 24
    
    mutations_to_execute = []

    for location in world.locations.values():
        for character in location.characters:
            if not character.schedule:
                continue
            
            target_location_id = character.schedule.get(f"{current_hour:02d}:00")
            if target_location_id and location.id != target_location_id:
                mutation = {
                    "op": "move_npc",
                    "character_name": character.name,
                    "new_location_id": target_location_id
                }
                mutations_to_execute.append(mutation)
                logging.info(f"NPC '{character.name}' is scheduled to move to '{target_location_id}'.")

    if mutations_to_execute:
        execute_world_mutations(game_state, world, mutations_to_execute)

def check_and_trigger_world_events(
    game_state: GameState,
    world: GameWorld,
    ai_manager: 'AIManager',
    old_minutes: int,
    display: DisplayManager,
    managers: Dict[str, Any]
):
    old_hour = old_minutes // 60
    new_hour = game_state.minutes_elapsed // 60
    
    if new_hour > old_hour:
        logging.info(f"Time has passed into a new hour ({old_hour} -> {new_hour}). Checking for world events.")
        
        execute_npc_schedules(game_state, world)

        npc_behavior_manager = managers.get("npc_behavior")
        if npc_behavior_manager:
            npc_mutations = npc_behavior_manager.update_behaviors(game_state, world, ai_manager)
            if npc_mutations:
                execute_world_mutations(game_state, world, npc_mutations)
        
        weather_manager = managers.get("weather")
        if weather_manager:
            weather_mutations = weather_manager.update_weather(game_state, world, ai_manager)
            if weather_mutations:
                execute_world_mutations(game_state, world, weather_mutations)
        
        event_data = ai_manager.generate_world_event(game_state, world)
        if event_data:
            summary = event_data.get("narration_summary")
            mutations = event_data.get("mutations", [])
            
            if summary:
                display.system_message(f"\n[Time Passes...] {summary}")
            
            if mutations:
                execute_world_mutations(game_state, world, mutations)

def handle_npc_state_update(game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict, action_desc: str, narration: str):
    if intent_data.get("intent") != "dialogue":
        return

    target_name = intent_data.get("target")
    if not target_name:
        return

    npc = game_state.find_character_in_location(target_name, world)
    if not npc:
        return

    npc_update_data = ai_manager.update_npc_state(npc, action_desc, narration)
    if npc_update_data:
        new_mood = npc_update_data.get("new_mood")
        new_memory = npc_update_data.get("new_memory")
        if new_mood:
            logging.info(f"Updating NPC '{npc.name}' mood from '{npc.mood}' to '{new_mood}'.")
            npc.mood = new_mood
        if new_memory:
            logging.info(f"Adding new memory to NPC '{npc.name}': '{new_memory}'")
            npc.memory.append(new_memory)

FILE: game_mechanics.py
import random
import logging
from typing import Dict

from game_state import Character

def calculate_stat_modifier(stat_value: int) -> int:
    return (stat_value - 10) // 2

def perform_skill_check(player: Character, skill: str, dc: int) -> bool:
    skill = skill.lower()
    player_stat_value = player.stats.get(skill, 10)
    
    if player_stat_value is None:
        logging.warning(f"Player '{player.name}' has no stat named '{skill}'. Defaulting to 10.")
        player_stat_value = 10
        
    modifier = calculate_stat_modifier(player_stat_value)
    roll = random.randint(1, 20)
    total = roll + modifier

    logging.info(f"--- SKILL CHECK: {skill.upper()} ---")
    logging.info(f"  - Difficulty Class (DC): {dc}")
    logging.info(f"  - Player Stat ({skill}): {player_stat_value} (Modifier: {modifier:+.0f})")
    logging.info(f"  - Dice Roll (d20): {roll}")
    logging.info(f"  - Total: {total}")

    if total >= dc:
        logging.info("  - Result: SUCCESS")
        return True
    else:
        logging.info("  - Result: FAILURE")
        return False

FILE: game_state.py
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, Tuple
import json
import logging

from definitions.entities import Character, Item
from definitions.world_objects import Location, Interactable
from definitions.quests import Quest

@dataclass
class GameWorld:
    locations: Dict[str, Location] = field(default_factory=dict)

    def get_location(self, location_id: str) -> Optional[Location]:
        return self.locations.get(location_id)
    
    def find_character_anywhere(self, character_name: str) -> Optional[Tuple[Character, Location]]:
        for loc in self.locations.values():
            for char in loc.characters:
                if char.name.lower() == character_name.lower():
                    return char, loc
        return None
    
    def to_dict(self) -> Dict[str, Any]:
        return { "locations": {loc_id: loc.to_dict() for loc_id, loc in self.locations.items()} }

    def create_and_add_location(self, location_data: Dict[str, Any]) -> Optional[Location]:
        try:
            loc_id = location_data['id']
            
            items = [Item(**item) for item in location_data.get('items', [])]
            interactables = [Interactable(**i) for i in location_data.get('interactables', [])]
            characters = []
            for char_data in location_data.get('characters', []):
                char_init_data = {
                    'name': char_data['name'],
                    'description': char_data['description'],
                    'stats': char_data['stats'],
                    'inventory': [],
                    'mood': char_data.get('mood', 'neutral'),
                    'memory': char_data.get('memory', []),
                    'personality_tags': char_data.get('personality_tags', []),
                    'hp': char_data.get('hp', 20),
                    'max_hp': char_data.get('max_hp', 20),
                    'status_effects': char_data.get('status_effects', []),
                    'level': char_data.get('level', 1),
                    'xp': char_data.get('xp', 0),
                    'xp_to_next_level': char_data.get('xp_to_next_level', 100),
                    'base_armor_class': char_data.get('base_armor_class', 10),
                    'base_attack_bonus': char_data.get('base_attack_bonus', 0),
                    'is_hostile': char_data.get('is_hostile', False),
                    'faction': char_data.get('faction', None),
                    'schedule': char_data.get('schedule', None)
                }
                characters.append(Character(**char_init_data))

            new_location = Location(
                id=loc_id,
                name=location_data['name'],
                description=location_data['description'],
                characters=characters,
                items=items,
                interactables=interactables,
                exits=location_data.get('exits', {})
            )
            self.locations[loc_id] = new_location
            logging.info(f"Successfully created and added new location '{loc_id}' to the world.")
            return new_location
        except (KeyError, TypeError) as e:
            logging.error(f"Failed to create location from AI-generated data. Missing key or wrong type: {e}. Data: {location_data}")
            return None


@dataclass
class GameState:
    player: Character
    current_location_id: str
    turn_count: int = 0
    minutes_elapsed: int = 480 
    quest_log: Dict[str, Quest] = field(default_factory=dict)
    combat_state: Optional[Dict[str, Any]] = None
    reputation: Dict[str, int] = field(default_factory=dict)
    player_knowledge: Dict[str, Any] = field(default_factory=dict)

    @property
    def time_of_day(self) -> str:
        hour = (self.minutes_elapsed // 60) % 24
        if 5 <= hour < 12:
            return "Morning"
        elif 12 <= hour < 17:
            return "Afternoon"
        elif 17 <= hour < 21:
            return "Evening"
        else:
            return "Night"

    def get_current_location(self, world: GameWorld) -> Optional[Location]:
        return world.get_location(self.current_location_id)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "player": self.player.to_dict(),
            "current_location_id": self.current_location_id,
            "turn_count": self.turn_count,
            "time_of_day": self.time_of_day,
            "minutes_elapsed": self.minutes_elapsed,
            "quest_log": {qid: q.to_dict() for qid, q in self.quest_log.items()},
            "combat_state": self.combat_state,
            "reputation": self.reputation,
            "player_knowledge": self.player_knowledge,
        }

    def get_context_string(self, world: GameWorld) -> str:
        current_location = self.get_current_location(world)
        if not current_location:
            return json.dumps({"error": f"current location '{self.current_location_id}' not found in world"})

        state_dict = self.to_dict()
        state_dict["location"] = current_location.to_dict()
        
        player_data = state_dict.pop("player")
        state_dict["player"] = player_data
        
        return json.dumps(state_dict, indent=2)

    def find_in_location(self, name: str, world: GameWorld) -> Optional[Tuple[Any, str]]:
        location = self.get_current_location(world)
        if not location: return None
        
        name_lower = name.lower()
        
        for char in location.characters:
            if name_lower in char.name.lower():
                return char, "character"
        for item in location.items:
            if name_lower in item.name.lower():
                return item, "item"
        for i in location.interactables:
            if name_lower in i.name.lower() or name_lower in i.id.lower():
                return i, "interactable"
        return None

    def find_item_in_location(self, name: str, world: GameWorld) -> Optional[Item]:
        result = self.find_in_location(name, world)
        return result[0] if result and result[1] == "item" else None

    def find_character_in_location(self, name: str, world: GameWorld) -> Optional[Character]:
        result = self.find_in_location(name, world)
        return result[0] if result and result[1] == "character" else None
        
    def find_interactable_in_location(self, name: str, world: GameWorld) -> Optional[Interactable]:
        result = self.find_in_location(name, world)
        return result[0] if result and result[1] == "interactable" else None
    
    def move_item_from_location_to_player(self, item: Item, world: GameWorld):
        location = self.get_current_location(world)
        if location:
            try:
                location.remove_item(item)
                self.player.add_item_to_inventory(item)
            except ValueError:
                logging.error(f"Attempted to move item '{item.name}' that was not in location '{location.id}'.")

FILE: main.py
import logging
from typing import Tuple, Optional, Dict, Any

from ai_manager import AIManager
from game_state import GameState, GameWorld
from definitions.entities import Character
from game_mechanics import perform_skill_check
from persistence import PersistenceManager
from action_processor import ActionProcessor
from meta_command_handler import MetaCommandHandler
from world_loader import WorldLoader
from event_executor import (
    execute_player_mutations, 
    check_and_trigger_world_events,
    handle_npc_state_update
)
from action_handlers.item_handler import ItemHandler
from action_handlers.combat_handler import CombatHandler
from action_handlers.interaction_handler import InteractionHandler
from action_handlers.dialogue_handler import DialogueHandler
from action_handlers.equipment_handler import EquipmentHandler
from action_handlers.crafting_handler import CraftingHandler
from action_handlers.quest_handler import QuestHandler
from display_manager import DisplayManager

# Corrected imports from the new managers/ directory
from managers.quest_manager import QuestManager
from managers.progression_manager import ProgressionManager
from managers.reputation_manager import ReputationManager
from managers.companion_manager import CompanionManager
from managers.npc_behavior_manager import NPCBehaviorManager
from managers.weather_manager import WeatherManager

def setup_new_game() -> Tuple[GameState, GameWorld]:
    logging.info("Setting up a new game world.")
    
    world_loader = WorldLoader(locations_data_dir="data/locations")
    world = world_loader.load_world()

    player = Character(
        name="Arion",
        description="A determined adventurer with a strong arm and a quick wit.",
        stats={"strength": 16, "dexterity": 12, "intelligence": 14},
    )
    
    game_state = GameState(player=player, current_location_id="salty_siren_tavern")

    return game_state, world

def game_loop(
    game_state: GameState, 
    world: GameWorld, 
    ai_manager: AIManager, 
    meta_handler: MetaCommandHandler,
    intent_handlers: Dict[str, Any],
    display: DisplayManager,
    managers: Dict[str, Any]
):
    # Retrieve managers from the dictionary
    quest_manager = managers["quest"]
    progression_manager = managers["progression"]
    reputation_manager = managers["reputation"]
    
    command_aliases = { "i": "inventory", "eq": "equipment", "l": "look" }

    while True:
        try:
            prompt_str = "> "
            if game_state.combat_state:
                if len(game_state.combat_state["participants"]) > game_state.combat_state["turn_index"]:
                    active_char_name = game_state.combat_state["participants"][game_state.combat_state["turn_index"]]
                    if active_char_name == game_state.player.name:
                        prompt_str = "[COMBAT] > "

            full_input = input(f"\n{prompt_str}")
            if not full_input:
                continue
            
            processed_input = full_input.lower().strip()
            if processed_input in command_aliases:
                full_input = command_aliases[processed_input]
            
            command_was_handled, new_state, new_world = meta_handler.handle_command(full_input, game_state, world, display)
            
            if command_was_handled:
                if new_state is None:
                    break
                assert new_world is not None
                game_state = new_state
                world = new_world
                continue

            old_minutes_elapsed = game_state.minutes_elapsed
            game_state.turn_count += 1
            original_location_id = game_state.current_location_id
            
            intent_data = ai_manager.get_player_intent(game_state, world, full_input)
            if not intent_data or not isinstance(intent_data, dict):
                display.show_error("The DM seems to have misunderstood you. Please try rephrasing your action.")
                continue

            intent = intent_data.get("intent")
            if not isinstance(intent, str):
                display.show_error("The DM's intentions are unclear. Please try rephrasing your action.")
                continue

            action_desc = intent_data.get("action_description", f"The player attempts: {full_input}")
            result_string = f"Failure: The intent '{intent}' is not recognized by the game."

            # Pass the display manager to the handlers
            intent_data["display"] = display 

            handler = intent_handlers.get(intent)
            if handler:
                result_string = handler(game_state, world, ai_manager, intent_data)
            elif intent == "skill_check":
                mechanics_data = ai_manager.determine_skill_check_details(game_state, world, action_desc)
                if not mechanics_data or not mechanics_data.get("is_possible", False) or "skill" not in mechanics_data or "dc" not in mechanics_data:
                    result_string = "Failure: The DM seems confused about the rules for that."
                else:
                    success = perform_skill_check(game_state.player, mechanics_data["skill"], mechanics_data["dc"])
                    result_string = "Success" if success else "Failure"
                    mutations_to_apply = mechanics_data.get("on_success" if success else "on_failure", [])
                    execute_player_mutations(game_state, mutations_to_apply)

            if "Failure" not in result_string and "Impossible" not in result_string and not game_state.combat_state:
                 if intent != "pass_time":
                    game_state.minutes_elapsed += 5

            narration = ai_manager.narrate_outcome(game_state, world, action_desc, result_string)
            display.narrate(narration)
            
            handle_npc_state_update(game_state, world, ai_manager, intent_data, action_desc, narration)

            if intent == "give_item" or intent == "attack":
                target_name = intent_data.get("target")
                target_char = game_state.find_character_in_location(target_name, world) if target_name else None
                reputation_manager.process_event(game_state, intent, display, target=target_char)

            if intent == "move" and "Success" in result_string and game_state.current_location_id != original_location_id:
                display.show_location(game_state.get_current_location(world))
            
            if intent == "look" and intent_data.get("target") is None:
                display.show_location(game_state.get_current_location(world))

            quest_manager.check_for_updates(game_state, intent, result_string, intent_data, display)
            progression_manager.check_for_levelup(game_state, display)
            check_and_trigger_world_events(game_state, world, ai_manager, old_minutes_elapsed, display, managers)

        except KeyboardInterrupt:
            display.system_message("\nExiting game. Goodbye!")
            break
        except Exception as e:
            logging.error(f"An unexpected error occurred in the main loop: {e}", exc_info=True)
            display.system_message("\nA critical error occurred. The game must end. Please check the logs.")
            break

def main():
    logging.info("--- Gemini Dungeon Master Initializing ---")
    
    # Core Components
    persistence_manager = PersistenceManager()
    action_processor = ActionProcessor()
    display = DisplayManager()
    meta_handler = MetaCommandHandler(persistence_manager)

    # Initialize Managers
    managers = {
        "quest": QuestManager(),
        "progression": ProgressionManager(),
        "reputation": ReputationManager(),
        "companion": CompanionManager(),
        "npc_behavior": NPCBehaviorManager(),
        "weather": WeatherManager()
    }

    # Initialize Handlers that depend on Managers
    quest_handler = QuestHandler(managers["quest"])
    
    # Initialize standalone Handlers
    item_handler = ItemHandler()
    combat_handler = CombatHandler()
    interaction_handler = InteractionHandler()
    dialogue_handler = DialogueHandler()
    equipment_handler = EquipmentHandler()
    crafting_handler = CraftingHandler()
    
    # Define all intent handlers
    intent_handlers: Dict[str, Any] = {
        "move": action_processor.process_action,
        "take_item": action_processor.process_action,
        "pass_time": action_processor.process_action,
        "use_item": item_handler.process_item_intent,
        "drop_item": item_handler.process_item_intent,
        "give_item": item_handler.process_item_intent,
        "attack": combat_handler.process_combat_intent,
        "interact": interaction_handler.process_interaction_intent,
        "look": interaction_handler.process_interaction_intent,
        "dialogue": dialogue_handler.process_dialogue_intent,
        "equip": equipment_handler.process_equipment_intent,
        "unequip": equipment_handler.process_equipment_intent,
        "craft_item": crafting_handler.process_crafting_intent,
        "quest_action": quest_handler.process_quest_intent,
        "companion_command": managers["companion"].process_command_intent,
    }

    display.system_message("\n--- Welcome to Gemini Dungeon Master ---")
    
    game_state: Optional[GameState] = None
    world: Optional[GameWorld] = None
    
    existing_saves = persistence_manager.list_save_games()
    if existing_saves:
        display.system_message(f"Found existing save games: {', '.join(existing_saves)}")
        choice = input("Type a save name to load, or type 'new' to start a new game: ").lower()
        if choice != 'new':
            loaded_data = persistence_manager.load_game(choice)
            if loaded_data:
                game_state, world = loaded_data

    if not game_state or not world:
        try:
            game_state, world = setup_new_game()
            display.system_message("\n--- Your Adventure Begins ---")
        except Exception as e:
            logging.critical(f"Failed to setup new game from world data. Error: {e}")
            display.system_message("\nFATAL ERROR: Could not load the game world. Please check game data files.")
            return
    else:
        display.system_message("\n--- Resuming Your Adventure ---")

    if not game_state or not world:
        logging.critical("FATAL: Game state or world could not be initialized.")
        display.system_message("\nA critical error prevented the game from starting. Please check logs.")
        return

    try:
        ai_manager = AIManager()
    except Exception as e:
        logging.critical(f"Failed to initialize the AI Manager. Exiting. Error: {e}")
        return
    
    display.show_player_character(game_state.player)
    display.show_location(game_state.get_current_location(world))

    game_loop(game_state, world, ai_manager, meta_handler, intent_handlers, display, managers)

if __name__ == "__main__":
    main()

FILE: meta_command_handler.py
import logging
from typing import List, Optional, Tuple

from game_state import GameState, GameWorld, Character, Item
from persistence import PersistenceManager
from game_mechanics import calculate_stat_modifier
from display_manager import DisplayManager

class MetaCommandHandler:
    def __init__(self, persistence_manager: PersistenceManager):
        self.persistence_manager = persistence_manager
        
        self.no_arg_commands = {"quit", "exit", "inventory", "i", "stats", "character", "quests", "journal", "equipment", "eq", "help"}
        self.arg_commands = {"save", "load"}
        self.all_commands = self.no_arg_commands.union(self.arg_commands)

    def handle_command(self, full_input: str, game_state: GameState, world: GameWorld, display: DisplayManager) -> Tuple[bool, Optional[GameState], Optional[GameWorld]]:
        command_parts = full_input.lower().split()
        command = command_parts[0]

        if command not in self.all_commands:
            return False, game_state, world

        if command in self.no_arg_commands and len(command_parts) > 1:
            return False, game_state, world
        
        if command in self.arg_commands and len(command_parts) == 1:
            display.system_message(f"Usage: {command} <name>")
            return True, game_state, world

        if command in ["quit", "exit"]:
            self._handle_quit(display)
            return True, None, None

        elif command == "save":
            self._handle_save(command_parts, game_state, world, display)
            return True, game_state, world

        elif command == "load":
            loaded_data = self._handle_load(command_parts, display)
            if loaded_data:
                game_state, world = loaded_data
                display.system_message(f"Game loaded from slot '{command_parts[1]}'.")
                display.show_location(game_state.get_current_location(world))
                return True, game_state, world
            return True, game_state, world

        elif command in ["inventory", "i"]:
            display.show_inventory(game_state.player)
            return True, game_state, world
        
        elif command in ["stats", "character"]:
            display.show_character_sheet(game_state.player)
            return True, game_state, world
        
        elif command in ["quests", "journal"]:
            display.show_quest_journal(game_state)
            return True, game_state, world

        elif command in ["equipment", "eq"]:
            display.show_equipment(game_state.player)
            return True, game_state, world

        elif command == "help":
            display.show_help()
            return True, game_state, world
        
        return False, game_state, world

    def _handle_quit(self, display: DisplayManager):
        display.system_message("Thank you for playing!")

    def _handle_save(self, command_parts: List[str], game_state: GameState, world: GameWorld, display: DisplayManager):
        if len(command_parts) > 1:
            slot_name = command_parts[1]
            if self.persistence_manager.save_game(game_state, world, slot_name):
                display.system_message(f"Game saved to slot '{slot_name}'.")
            else:
                display.show_error("Failed to save the game.")
        else:
            display.system_message("Usage: save <slot_name>")
            
    def _handle_load(self, command_parts: List[str], display: DisplayManager) -> Optional[Tuple[GameState, GameWorld]]:
        if len(command_parts) > 1:
            slot_name = command_parts[1]
            loaded_data = self.persistence_manager.load_game(slot_name)
            if loaded_data:
                return loaded_data
            else:
                display.show_error(f"Failed to load game from slot '{slot_name}'.")
        else:
            display.system_message("Usage: load <slot_name>")
        return None

FILE: persistence.py
import json
import logging
from pathlib import Path
from typing import Optional, List, Tuple

from game_state import GameState, GameWorld, Character, Item, Location

class PersistenceManager:
    def __init__(self, save_directory: str = "saves"):
        self.save_path = Path(save_directory)
        self.save_path.mkdir(parents=True, exist_ok=True)
        logging.info(f"PersistenceManager initialized. Save directory: '{self.save_path.resolve()}'")

    def get_save_file_path(self, slot_name: str) -> Path:
        return self.save_path / f"{slot_name}.json"

    def list_save_games(self) -> List[str]:
        return [p.stem for p in self.save_path.glob("*.json")]

    def save_game(self, game_state: GameState, world: GameWorld, slot_name: str) -> bool:
        file_path = self.get_save_file_path(slot_name)
        logging.info(f"Attempting to save game to '{file_path}'...")
        try:
            full_save_data = {
                "game_state": game_state.to_dict(),
                "game_world": world.to_dict()
            }
            with open(file_path, 'w') as f:
                json.dump(full_save_data, f, indent=4)
            logging.info(f"Game successfully saved to slot '{slot_name}'.")
            return True
        except (IOError, TypeError) as e:
            logging.error(f"Failed to save game to slot '{slot_name}'. Error: {e}")
            return False

    def load_game(self, slot_name: str) -> Optional[Tuple[GameState, GameWorld]]:
        file_path = self.get_save_file_path(slot_name)
        if not file_path.exists():
            logging.warning(f"No save file found for slot '{slot_name}'.")
            return None

        logging.info(f"Attempting to load game from '{file_path}'...")
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)

            world_data = data['game_world']
            rebuilt_locations = {}
            for loc_id, loc_data in world_data['locations'].items():
                rebuilt_locations[loc_id] = self._rebuild_location(loc_data)
            
            world = GameWorld(locations=rebuilt_locations)

            state_data = data['game_state']
            player = self._rebuild_character(state_data['player'])
            
            game_state = GameState(
                player=player,
                current_location_id=state_data['current_location_id'],
                turn_count=state_data.get('turn_count', 0),
                minutes_elapsed=state_data.get('minutes_elapsed', 480)
            )
            
            logging.info(f"Game successfully loaded from slot '{slot_name}'.")
            return game_state, world

        except (IOError, json.JSONDecodeError, KeyError, TypeError) as e:
            logging.error(f"Failed to load game from '{file_path}'. File may be corrupt. Error: {e}")
            return None
    
    def _rebuild_character(self, char_data: dict) -> Character:
        inventory = [Item(**item) for item in char_data.get('inventory', [])]
        
        # Default HP to max_hp for backward compatibility with old saves
        max_hp = char_data.get('max_hp', 20)
        hp = char_data.get('hp', max_hp)

        return Character(
            name=char_data['name'],
            description=char_data['description'],
            stats=char_data['stats'],
            inventory=inventory,
            mood=char_data.get('mood', 'neutral'),
            memory=char_data.get('memory', []),
            hp=hp,
            max_hp=max_hp,
            status_effects=char_data.get('status_effects', [])
        )

    def _rebuild_location(self, loc_data: dict) -> Location:
        items = [Item(**item) for item in loc_data.get('items', [])]
        characters = [self._rebuild_character(char) for char in loc_data.get('characters', [])]
        return Location(
            id=loc_data['id'],
            name=loc_data['name'],
            description=loc_data['description'],
            characters=characters,
            items=items,
            exits=loc_data.get('exits', {})
        )

FILE: requirements.txt
# requirements.txt

# This file lists the Python packages required by this project.
# To install all dependencies, run the following command in your activated virtual environment:
# pip install -r requirements.txt

google-generativeai

FILE: world_loader.py
import json
import logging
from typing import Dict
from pathlib import Path

from game_state import GameWorld, Location, Character, Item
from definitions.quests import Quest, Objective

class WorldLoader:
    def __init__(self, locations_data_dir: str):
        self.locations_path = Path(locations_data_dir)

    def load_world(self) -> GameWorld:
        logging.info(f"Loading world data from directory '{self.locations_path}'...")
        
        rebuilt_locations = {}
        try:
            if not self.locations_path.is_dir():
                raise FileNotFoundError(f"The specified location directory does not exist: {self.locations_path}")

            for location_file in self.locations_path.glob("*.json"):
                logging.info(f"  - Loading location file: {location_file.name}")
                with open(location_file, 'r') as f:
                    loc_data = json.load(f)
                
                loc_id = loc_data.get("id")
                if not loc_id:
                    logging.warning(f"    - SKIPPING: Location file {location_file.name} is missing a required 'id'.")
                    continue
                
                rebuilt_locations[loc_id] = self._rebuild_location(loc_data)
            
            if not rebuilt_locations:
                raise ValueError("No valid location files were found in the specified directory.")

            world = GameWorld(locations=rebuilt_locations)
            logging.info("World data loaded and objects built successfully.")
            return world

        except (IOError, json.JSONDecodeError, KeyError, FileNotFoundError, ValueError) as e:
            logging.critical(f"Failed to load or parse world data. Error: {e}")
            raise

    def _rebuild_character(self, char_data: Dict) -> Character:
        max_hp = char_data.get('max_hp', 20)
        hp = char_data.get('hp', max_hp)

        return Character(
            name=char_data['name'],
            description=char_data['description'],
            stats=char_data['stats'],
            inventory=char_data.get('inventory', []),
            mood=char_data.get('mood', 'neutral'),
            memory=char_data.get('memory', []),
            available_quest_ids=char_data.get('available_quest_ids', []),
            hp=hp,
            max_hp=max_hp,
            status_effects=char_data.get('status_effects', [])
        )

    def _rebuild_location(self, loc_data: Dict) -> Location:
        items = [Item(**item) for item in loc_data.get('items', [])]
        characters = [self._rebuild_character(char) for char in loc_data.get('characters', [])]

        rebuilt_quests = []
        for quest_data in loc_data.get('quests', []):
            objectives = [Objective(**obj_data) for obj_data in quest_data.get('objectives', [])]
            quest = Quest(
                id=quest_data['id'],
                name=quest_data['name'],
                description=quest_data['description'],
                required_stat=quest_data.get('required_stat'),
                required_dc=quest_data.get('required_dc', 0),
                objectives=objectives
            )
            rebuilt_quests.append(quest)
        
        return Location(
            id=loc_data['id'],
            name=loc_data['name'],
            description=loc_data['description'],
            characters=characters,
            items=items,
            exits=loc_data.get('exits', {}),
            quests=rebuilt_quests
        )

FILE: action_handlers/__init__.py


FILE: action_handlers/combat_handler.py
import logging
import random
from typing import Dict, Any, TYPE_CHECKING, List, Optional

from definitions.entities import Character
from game_state import GameState, GameWorld

if TYPE_CHECKING:
    from ai_manager import AIManager

class CombatHandler:

    def process_combat_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        intent = intent_data.get("intent")

        if not game_state.combat_state and intent == "attack":
            return self._initiate_combat(game_state, world, ai_manager, intent_data)

        if game_state.combat_state:
            active_char_name = game_state.combat_state["participants"][game_state.combat_state["turn_index"]]
            if active_char_name != game_state.player.name:
                logging.error("Received player combat intent when it was not the player's turn.")
                return f"Failure: It is not your turn. {active_char_name} is acting."

            if intent == "attack":
                target_name = intent_data.get("target")
                if not target_name:
                    return "Failure: You must specify a target to attack."

                participants = self._get_combat_participants(game_state, world)
                target = next((p for p in participants if p.name.lower() == target_name.lower() and p != game_state.player), None)
                if not target:
                    return f"Failure: '{target_name}' is not in this fight."

                attack_narration = self._execute_attack(game_state, game_state.player, target)
                game_state.combat_state["turn_index"] += 1
                return self._run_combat_loop(game_state, world, ai_manager, initial_narration=attack_narration)
            
            return "Failure: That is not a valid action in combat."

        logging.warning(f"CombatHandler received an unhandled intent: {intent}")
        return "Failure: You can't do that right now."

    def _initiate_combat(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        target_name = intent_data.get("target")
        if not target_name:
            return "Failure: Who are you trying to attack?"

        target = game_state.find_character_in_location(target_name, world)
        if not target:
            return f"Failure: You don't see '{target_name}' here."

        if target == game_state.player:
            return "Failure: You decide against attacking yourself."

        logging.info(f"Combat initiated by player against '{target.name}'.")

        location = game_state.get_current_location(world)
        if not location:
            logging.error("Cannot initiate combat in a non-existent location.")
            return "Failure: You cannot fight in the void."

        initial_participants = [game_state.player] + [char for char in location.characters if char.is_hostile or char == target]
        for p in initial_participants:
            p.is_hostile = True

        turn_order = sorted(initial_participants, key=lambda x: random.randint(1, 20) + (x.stats.get("dexterity", 10) - 10) // 2, reverse=True)

        game_state.combat_state = {
            "participants": [p.name for p in turn_order],
            "turn_index": 0,
            "round_count": 1
        }
        
        initial_narration = f"You draw your weapon and attack {target.name}! Combat has begun."
        attack_narration = self._execute_attack(game_state, game_state.player, target)

        game_state.combat_state["turn_index"] += 1
        return self._run_combat_loop(game_state, world, ai_manager, initial_narration=f"{initial_narration}\n{attack_narration}")

    def _get_combat_participants(self, game_state: GameState, world: GameWorld) -> List[Character]:
        if not game_state.combat_state:
            return []

        location = game_state.get_current_location(world)
        if not location:
            return []

        participant_names = game_state.combat_state.get("participants", [])
        all_chars = [game_state.player] + location.characters
        
        participant_objects = []
        for name in participant_names:
            found_char = next((char for char in all_chars if char.name == name), None)
            if found_char:
                participant_objects.append(found_char)
        
        return participant_objects

    def _run_combat_loop(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', initial_narration: str = "") -> str:
        narration_log = [initial_narration] if initial_narration else []

        while game_state.combat_state:
            end_state = self._check_combat_end(game_state, world)
            if end_state:
                game_state.combat_state = None
                narration_log.append(end_state)
                return "\n".join(filter(None, narration_log))

            turn_index = game_state.combat_state["turn_index"]
            participant_names = game_state.combat_state["participants"]
            
            if turn_index >= len(participant_names):
                game_state.combat_state["turn_index"] = 0
                game_state.combat_state["round_count"] += 1
                narration_log.append(f"--- Round {game_state.combat_state['round_count']} ---")
                continue

            participants = self._get_combat_participants(game_state, world)
            if not participants:
                game_state.combat_state = None
                return "Victory: The last foe falls, and the dust settles."
            
            attacker = participants[turn_index]
            
            if attacker.hp <= 0:
                game_state.combat_state["turn_index"] += 1
                continue

            if attacker == game_state.player:
                narration_log.append("It is your turn to act.")
                return "\n".join(filter(None, narration_log))
            else:
                npc_action = self._get_npc_combat_action(attacker, game_state, world, ai_manager)
                
                if npc_action and npc_action.get("action") == "attack":
                    target_name = npc_action.get("target")
                    target = game_state.player if target_name == game_state.player.name else None
                    if target:
                        narration_log.append(self._execute_attack(game_state, attacker, target))
                else:
                    narration_log.append(f"{attacker.name} hesitates, unsure what to do.")
            
            game_state.combat_state["turn_index"] += 1
        
        return "\n".join(filter(None, narration_log))

    def _get_npc_combat_action(self, npc: Character, game_state: GameState, world: GameWorld, ai_manager: 'AIManager') -> Dict[str, Any]:
        logging.info(f"Getting combat action for NPC '{npc.name}'.")
        return {
            "action": "attack",
            "target": game_state.player.name
        }

    def _execute_attack(self, game_state: GameState, attacker: Character, target: Character) -> str:
        def get_attack_roll(char: Character) -> int:
            modifier = (char.stats.get("strength", 10) - 10) // 2 + char.get_total_attack_bonus()
            return random.randint(1, 20) + modifier
        
        def get_damage_amount(char: Character) -> int:
            dice_str = char.get_damage_dice()
            num_dice, dice_size = map(int, dice_str.split('d'))
            return sum(random.randint(1, dice_size) for _ in range(num_dice))

        attack_roll = get_attack_roll(attacker)
        target_ac = target.get_total_armor_class()

        if attack_roll >= target_ac:
            damage = get_damage_amount(attacker)
            target.hp -= damage
            logging.info(f"HIT! {attacker.name} attacks {target.name} for {damage} damage. {target.name} HP: {target.hp}/{target.max_hp}")
            
            narration = f"{attacker.name}'s attack hits {target.name} for {damage} damage!"
            if target.hp <= 0:
                narration += f" {target.name} collapses, defeated!"
                if game_state.combat_state:
                    self._remove_defeated_participant(character=target, game_state=game_state)
            return narration
        else:
            logging.info(f"MISS! {attacker.name} attacks {target.name} but fails to hit.")
            return f"{attacker.name} attacks {target.name} but misses."

    def _check_combat_end(self, game_state: GameState, world: GameWorld) -> Optional[str]:
        participants = self._get_combat_participants(game_state, world)
        
        if game_state.player.hp <= 0:
            return "Defeat: You have been vanquished."

        living_opponents = [p for p in participants if p != game_state.player and p.hp > 0]
        if not living_opponents:
            return "Victory: The last of your foes has been defeated!"
        
        return None
    
    def _remove_defeated_participant(self, character: Character, game_state: GameState):
        if game_state.combat_state and character.name in game_state.combat_state["participants"]:
            current_turn_index = game_state.combat_state["turn_index"]
            defeated_char_index = -1
            try:
                defeated_char_index = game_state.combat_state["participants"].index(character.name)
            except ValueError:
                logging.warning(f"Tried to remove defeated participant '{character.name}' who was already removed.")
                return

            game_state.combat_state["participants"].remove(character.name)
            
            if defeated_char_index < current_turn_index:
                game_state.combat_state["turn_index"] -= 1

FILE: action_handlers/crafting_handler.py
class CraftingHandler:
    def __init__(self):
        pass

    def process_crafting_intent(self, *args, **kwargs):
        return "Failure: Crafting is not yet implemented."

FILE: action_handlers/dialogue_handler.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from game_state import GameState, GameWorld, Character
from game_mechanics import perform_skill_check
from definitions.quests import Quest

if TYPE_CHECKING:
    from ai_manager import AIManager

class DialogueHandler:

    def _get_quest_from_location(self, quest_id: str, location: Any) -> Quest | None:
        if not location:
            return None
        return location.get_quest_by_id(quest_id)

    def _handle_work_inquiry(self, game_state: GameState, world: GameWorld, npc: Character) -> str:
        current_location = game_state.get_current_location(world)
        if not current_location or not npc.available_quest_ids:
            logging.info(f"NPC '{npc.name}' has no available quests.")
            return "The player is asking for work, but you have none to offer. Politely tell them you don't have any jobs right now."

        quest_id_to_offer = npc.available_quest_ids[0]
        quest_to_offer = self._get_quest_from_location(quest_id_to_offer, current_location)

        if not quest_to_offer:
            logging.error(f"NPC '{npc.name}' has quest ID '{quest_id_to_offer}' but it was not found in location '{current_location.id}'.")
            return "You had a job in mind, but the details seem to have slipped your mind. You tell the player to check back later."

        passed_check = True
        if quest_to_offer.required_stat and quest_to_offer.required_dc > 0:
            logging.info(f"Quest '{quest_to_offer.name}' requires a check: {quest_to_offer.required_stat} DC {quest_to_offer.required_dc}.")
            passed_check = perform_skill_check(game_state.player, quest_to_offer.required_stat, quest_to_offer.required_dc)

        if passed_check:
            logging.info("Player passed the stat check. NPC will offer the quest.")
            return f"The player seems capable. You should offer them the '{quest_to_offer.name}' quest and describe it."
        else:
            logging.info("Player failed the stat check. NPC will refuse to offer the quest.")
            return f"The player does not seem capable enough for the '{quest_to_offer.name}' quest. Politely tell them they aren't the right fit."

    def _handle_action_request(self, game_state: GameState, world: GameWorld, npc: Character, topic: str) -> str:
        parts = topic.split(':')
        if len(parts) < 3:
            return "Failure: The request was unclear."

        action = parts[1]
        action_target_name = parts[2]

        if action == "unlock":
            if npc.mood in ['friendly', 'grateful', 'impressed']:
                target_obj = game_state.find_interactable_in_location(action_target_name, world)
                if target_obj and "locked" in target_obj.state:
                    if target_obj.state["locked"]:
                        logging.info(f"NPC '{npc.name}' is willing and able to unlock '{target_obj.name}'.")
                        target_obj.state["locked"] = False
                        return f"Success: Dialogue - {npc.name} nods. 'Of course.' He walks over and unlocks the {target_obj.name} with a click."
                    else:
                        return f"Success: Dialogue - {npc.name} looks at the {target_obj.name} and says, 'It's already unlocked.'"
                else:
                    return f"Success: Dialogue - {npc.name} looks confused and says, 'I can't seem to find a {action_target_name} to unlock.'"
            else:
                logging.info(f"NPC '{npc.name}' is not friendly enough to fulfill the request.")
                return f"Success: Dialogue - {npc.name} scoffs, 'And why would I do that for you?'"
        
        return "Failure: The NPC doesn't know how to do that."

    def process_dialogue_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        target_name = intent_data.get("target")
        if not target_name:
            logging.warning("Dialogue intent was missing a 'target' character.")
            return "Failure: You need to specify who you want to talk to."
            
        npc = game_state.find_character_in_location(target_name, world)
        if not npc:
            logging.info(f"Player tried to talk to '{target_name}', but they were not found.")
            return f"Failure: You don't see '{target_name}' here."
        
        topic = intent_data.get("topic", "").lower()
        final_topic = topic

        if topic.startswith("request:"):
            return self._handle_action_request(game_state, world, npc, topic)

        is_asking_for_work = any(keyword in topic for keyword in ["work", "job", "task", "quest"])
        if is_asking_for_work:
            final_topic = self._handle_work_inquiry(game_state, world, npc)

        dialogue_response = ai_manager.generate_dialogue_response(
            game_state=game_state,
            world=world,
            npc=npc,
            topic=final_topic
        )

        if dialogue_response:
            return f"Success: Dialogue - {dialogue_response}"
        else:
            logging.error(f"AI failed to generate dialogue response for NPC '{npc.name}'.")
            return "Failure: They don't seem to respond."

FILE: action_handlers/equipment_handler.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from definitions.entities import Character, Item
from game_state import GameState, GameWorld

if TYPE_CHECKING:
    from ai_manager import AIManager

class EquipmentHandler:

    def process_equipment_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        intent = intent_data.get("intent")
        
        if intent == "equip":
            return self._handle_equip(game_state, intent_data)
        elif intent == "unequip":
            return self._handle_unequip(game_state, intent_data)
        
        logging.warning(f"EquipmentHandler received an unhandled intent: {intent}")
        return "Failure: The world doesn't know how to do that."

    def _find_item_in_inventory(self, player: Character, item_name: str) -> Item | None:
        if not player.inventory: return None
        for item in player.inventory:
            if item_name.lower() in item.name.lower():
                return item
        return None

    def _handle_equip(self, game_state: GameState, intent_data: Dict[str, Any]) -> str:
        item_name = intent_data.get("target")
        if not item_name:
            return "Failure: You need to specify what item to equip."

        item_to_equip = self._find_item_in_inventory(game_state.player, item_name)
        if not item_to_equip:
            return f"Failure: You do not have a '{item_name}' in your inventory."
        
        slot = item_to_equip.equipment_slot
        if not slot:
            return f"Failure: The {item_to_equip.name} is not something you can equip."

        # Unequip any item currently in that slot
        currently_equipped_item = game_state.player.equipment.get(slot)
        if currently_equipped_item:
            game_state.player.equipment[slot] = None
            game_state.player.add_item_to_inventory(currently_equipped_item)
            logging.info(f"Player automatically unequipped '{currently_equipped_item.name}' to make room for '{item_to_equip.name}'.")

        # Equip the new item
        game_state.player.equipment[slot] = item_to_equip
        game_state.player.remove_item_from_inventory(item_to_equip)
        logging.info(f"Player equipped '{item_to_equip.name}' into slot '{slot}'.")

        return f"Success: Equipped {item_to_equip.name}"

    def _handle_unequip(self, game_state: GameState, intent_data: Dict[str, Any]) -> str:
        item_name = intent_data.get("target")
        if not item_name:
            return "Failure: You need to specify what item to unequip."

        item_to_unequip = None
        target_slot = None

        # Find the item in the equipment slots
        for slot, item in game_state.player.equipment.items():
            if item and item_name.lower() in item.name.lower():
                item_to_unequip = item
                target_slot = slot
                break

        if not item_to_unequip or not target_slot:
            return f"Failure: You do not have a '{item_name}' equipped."
        
        # Move item from equipment to inventory
        game_state.player.equipment[target_slot] = None
        game_state.player.add_item_to_inventory(item_to_unequip)
        logging.info(f"Player unequipped '{item_to_unequip.name}' from slot '{target_slot}'.")

        return f"Success: Unequipped {item_to_unequip.name}"

FILE: action_handlers/interaction_handler.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from definitions.entities import Item
from game_state import GameState, GameWorld

if TYPE_CHECKING:
    from ai_manager import AIManager

class InteractionHandler:

    def process_interaction_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        intent = intent_data.get("intent")
        
        if intent == "interact":
            return self._handle_interact(game_state, world, intent_data)
        elif intent == "look":
            return self._handle_look(game_state, world, intent_data)
        
        logging.warning(f"InteractionHandler received an unhandled intent: {intent}")
        return "Failure: The world doesn't know how to do that."
    
    def _handle_look(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        target_name = intent_data.get("target")

        if not target_name:
            logging.info("Player looked at surroundings (no specific target).")
            return "Automatic Success: Look at surroundings"

        target_obj, obj_type = None, None
        
        found_in_location = game_state.find_in_location(target_name, world)
        if found_in_location:
            target_obj, obj_type = found_in_location
        
        if not target_obj and game_state.player.inventory:
            player_item = next((item for item in game_state.player.inventory if target_name.lower() in item.name.lower()), None)
            if player_item:
                target_obj = player_item
                obj_type = "item_in_inventory"
        
        if not target_obj:
            return f"Failure: You don't see any '{target_name}' here."

        return f"Success: Look at {obj_type} - {target_obj.name}"

    def _handle_interact(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        target_name = intent_data.get("target")
        if not target_name:
            return "Failure: You need to specify what to interact with."

        found_in_location = game_state.find_in_location(target_name, world)
        if not found_in_location:
            return f"Failure: You can't seem to find a '{target_name}' here."

        target_obj, obj_type = found_in_location
        if obj_type != "interactable":
            return f"Failure: You can't seem to interact with the '{target_name}' in that way."

        if target_obj.state.get("locked"):
            return f"Failure: The {target_obj.name} is locked."

        if 'container' in target_obj.state:
            if not target_obj.state.get('opened'):
                target_obj.state['opened'] = True
                logging.info(f"Player opened container '{target_obj.name}'.")
                
                location = game_state.get_current_location(world)
                if not location: return "Failure: Cannot interact without a valid location."

                loot = target_obj.state.get('container', [])
                if loot:
                    for item_data in loot:
                        location.items.append(Item(**item_data))
                    target_obj.state['container'] = []
                    return "Success: Open and loot"
                else:
                    return "Success: Open empty"
            else:
                return "Failure: It is already open."
        
        if 'toggled' in target_obj.state:
            current_state = target_obj.state['toggled']
            target_obj.state['toggled'] = not current_state
            logging.info(f"Player toggled '{target_obj.name}' from {current_state} to {not current_state}.")
            return "Success"
            
        return f"Failure: You're not sure how to interact with the {target_obj.name}."

FILE: action_handlers/item_handler.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from definitions.entities import Character, Item
from game_state import GameState, GameWorld

if TYPE_CHECKING:
    from ai_manager import AIManager

class ItemHandler:

    def process_item_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        intent = intent_data.get("intent")
        
        if intent == "use_item":
            return self._handle_use_item(game_state, world, intent_data)
        elif intent == "drop_item":
            return self._handle_drop_item(game_state, world, intent_data)
        elif intent == "give_item":
            return self._handle_give_item(game_state, world, intent_data)
        
        logging.warning(f"ItemHandler received an unhandled intent: {intent}")
        return "Failure: The world doesn't know how to do that."

    def _find_item_in_inventory(self, player: Character, item_name: str) -> Item | None:
        if not player.inventory: return None
        for item in player.inventory:
            if item_name.lower() in item.name.lower():
                return item
        return None

    def _handle_use_item(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        item_name = intent_data.get("target")
        if not item_name:
            return "Failure: You need to specify what item to use."

        item_to_use = self._find_item_in_inventory(game_state.player, item_name)
        if not item_to_use:
            return f"Failure: You do not have a '{item_name}'."
        
        if not item_to_use.use_effect:
            return f"Failure: The {item_to_use.name} doesn't seem to have a use."

        effect_op = item_to_use.use_effect.get("op")
        if effect_op == "heal":
            amount = item_to_use.use_effect.get("amount", 0)
            game_state.player.hp = min(game_state.player.max_hp, game_state.player.hp + amount)
            logging.info(f"Player used {item_to_use.name}, healing for {amount}. New HP: {game_state.player.hp}")
            if item_to_use.category == "potion":
                game_state.player.remove_item_from_inventory(item_to_use)
            return "Success"

        elif effect_op == "unlock":
            target_on_name = intent_data.get("target_on")
            if not target_on_name:
                return "Failure: What do you want to use the key on?"
            
            found_in_location = game_state.find_in_location(target_on_name, world)
            if not found_in_location:
                 return f"Failure: You don't see a '{target_on_name}' to use this on."
            
            target_obj, obj_type = found_in_location
            if obj_type != "interactable":
                return f"Failure: You can't use the key on a {obj_type}."

            if item_to_use.unlocks_id == target_obj.id and target_obj.state.get("locked"):
                target_obj.state["locked"] = False
                logging.info(f"Player used {item_to_use.name} to unlock {target_obj.name}.")
                return "Success"
            else:
                return f"Failure: It doesn't seem to work on the {target_obj.name}."

        return f"Failure: You can't figure out how to use the {item_to_use.name}."

    def _handle_drop_item(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        item_name = intent_data.get("target")
        if not item_name:
            return "Failure: You need to specify what to drop."

        item_to_drop = self._find_item_in_inventory(game_state.player, item_name)
        if not item_to_drop:
            return f"Failure: You do not have a '{item_name}'."

        location = game_state.get_current_location(world)
        if not location:
            return "Failure: You are in a void and cannot drop things here."
        
        game_state.player.remove_item_from_inventory(item_to_drop)
        location.items.append(item_to_drop)
        logging.info(f"Player dropped '{item_to_drop.name}' in '{location.id}'.")
        return "Success"

    def _handle_give_item(self, game_state: GameState, world: GameWorld, intent_data: Dict[str, Any]) -> str:
        item_name = intent_data.get("target")
        recipient_name = intent_data.get("recipient")

        if not item_name or not recipient_name:
            return "Failure: You need to specify both an item and who to give it to."
        
        item_to_give = self._find_item_in_inventory(game_state.player, item_name)
        if not item_to_give:
            return f"Failure: You do not have a '{item_name}'."
        
        recipient = game_state.find_character_in_location(recipient_name, world)
        if not recipient:
            return f"Failure: You don't see '{recipient_name}' here."

        game_state.player.remove_item_from_inventory(item_to_give)
        recipient.add_item_to_inventory(item_to_give)
        logging.info(f"Player gave '{item_to_give.name}' to NPC '{recipient.name}'.")
        return "Success"

FILE: action_handlers/quest_handler.py
import logging
from typing import Dict, Any, TYPE_CHECKING

from game_state import GameState, GameWorld, Character
from event_executor import execute_world_mutations
from managers.quest_manager import QuestManager

if TYPE_CHECKING:
    from ai_manager import AIManager
    from display_manager import DisplayManager

class QuestHandler:

    def __init__(self, quest_manager: QuestManager):
        self.quest_manager = quest_manager

    def process_quest_intent(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        action_type = intent_data.get("action_type")
        
        # This is the fix: convert the action_type to lowercase before comparing.
        if action_type and action_type.lower() == "accept":
            return self._handle_accept_quest(game_state, world, ai_manager, intent_data)
        
        logging.warning(f"QuestHandler received an unhandled action_type: {action_type}")
        return "Failure: You're not sure how to respond to that."

    def _handle_accept_quest(self, game_state: GameState, world: GameWorld, ai_manager: 'AIManager', intent_data: Dict[str, Any]) -> str:
        quest_giver_name = intent_data.get("target")
        if not quest_giver_name:
            return "Failure: The AI could not determine who gave the quest."

        quest_giver = game_state.find_character_in_location(quest_giver_name, world)
        if not quest_giver:
            # Fallback to searching the whole world if the target isn't in the current location.
            char_data = world.find_character_anywhere(quest_giver_name)
            if char_data:
                quest_giver, _ = char_data
            else:
                return f"Failure: You don't see {quest_giver_name} here to accept a quest from."

        quest_offer_memory = None
        for memory in reversed(quest_giver.memory):
            if "work" in memory.lower() or "job" in memory.lower() or "task" in memory.lower() or "catch" in memory.lower():
                quest_offer_memory = memory
                break
        
        if not quest_offer_memory:
            logging.warning(f"Player tried to accept a quest from '{quest_giver.name}', but no recent offer memory was found.")
            return "Failure: They don't seem to recall offering you any work."

        quest_data = ai_manager.generate_quest_from_context(quest_giver, quest_offer_memory)

        if not quest_data:
            logging.error(f"AI failed to generate quest data from memory: '{quest_offer_memory}'")
            return "Failure: There was a misunderstanding about the details of the job."
            
        display: 'DisplayManager' = intent_data["display"]
        self.quest_manager.start_quest(game_state, quest_data, display)
        
        # Example of a hardcoded quest trigger. This can be made more robust later.
        if "grog" in quest_data.get("id", ""):
            storeroom_door = game_state.find_interactable_in_location("storeroom door", world)
            if storeroom_door and storeroom_door.state.get("locked"):
                logging.info(f"Unlocking storeroom_door as part of quest acceptance.")
                storeroom_door.state["locked"] = False
                
                current_location = game_state.get_current_location(world)
                if current_location and "salty_siren_storeroom" not in current_location.exits.values():
                    mutation = {
                        "op": "add_exit",
                        "location_id": current_location.id,
                        "exit_description": "a heavy oak door to the storeroom",
                        "destination_id": "salty_siren_storeroom"
                    }
                    execute_world_mutations(game_state, world, [mutation])

        return "Success: Quest Accepted"

FILE: ai_providers/__init__.py


FILE: ai_providers/gemini_client.py
# ai_providers/gemini_client.py
import google.generativeai as genai
import logging

from config import GEMINI_API_KEY, MODEL_NAME

class GeminiClient:
    """A client for interacting with the Google Gemini API."""

    def __init__(self):
        try:
            genai.configure(api_key=GEMINI_API_KEY)
            self.model = genai.GenerativeModel(MODEL_NAME)
            logging.info(f"GeminiClient initialized successfully with model '{MODEL_NAME}'.")
        except Exception as e:
            logging.critical(f"Failed to configure GeminiClient. Is the API key valid? Error: {e}")
            raise

    def generate_content(self, prompt: str) -> str:
        """
        Generates content using the Gemini API.
        
        Args:
            prompt: The full prompt to send to the API.

        Returns:
            The raw text response from the API.

        Raises:
            Exception: Propagates any exception from the genai library call.
        """
        logging.info("Calling Gemini API...")
        response = self.model.generate_content(prompt)
        return response.text

FILE: ai_providers/ollama_client.py
import requests
import logging
from typing import Optional

from config import OLLAMA_BASE_URL, OLLAMA_MODEL, OLLAMA_TIMEOUT

class OllamaClient:

    def __init__(self):
        self.base_url = OLLAMA_BASE_URL
        self.model = OLLAMA_MODEL
        self.timeout = OLLAMA_TIMEOUT
        logging.info(f"OllamaClient initialized for model '{self.model}' at '{self.base_url}' with a timeout of {self.timeout} seconds.")

    def generate_content(self, prompt: str, force_json: bool) -> Optional[str]:
        logging.info(f"Calling Ollama API with model '{self.model}' (JSON Mode: {force_json})...")
        try:
            payload = {
                "model": self.model,
                "prompt": prompt,
                "stream": False,
            }
            if force_json:
                payload["format"] = "json"

            response = requests.post(f"{self.base_url}/api/generate", json=payload, timeout=self.timeout)
            response.raise_for_status()
            
            response_json = response.json()
            return response_json.get("response")

        except requests.exceptions.Timeout:
            logging.error(f"Ollama call timed out after {self.timeout} seconds. The local model may be unresponsive or the task is too complex for the current hardware.")
            return None
        except requests.exceptions.RequestException as e:
            logging.error(f"Failed to connect to Ollama at '{self.base_url}'. Error: {e}")
            return None
        except Exception as e:
            logging.error(f"An unexpected error occurred during Ollama call: {e}")
            return None

FILE: definitions/__init__.py


FILE: definitions/entities.py
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

@dataclass
class Item:
    name: str
    description: str
    category: str = "misc"
    value: int = 0
    
    equipment_slot: Optional[str] = None
    stat_bonuses: Dict[str, int] = field(default_factory=dict)

    use_effect: Dict[str, Any] = field(default_factory=dict)
    damage_dice: Optional[str] = None
    damage_type: Optional[str] = None
    unlocks_id: Optional[str] = None
    owner: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description,
            "category": self.category,
            "value": self.value,
            "equipment_slot": self.equipment_slot,
            "stat_bonuses": self.stat_bonuses,
            "use_effect": self.use_effect,
            "damage_dice": self.damage_dice,
            "damage_type": self.damage_type,
            "unlocks_id": self.unlocks_id,
            "owner": self.owner,
        }

@dataclass
class Character:
    name: str
    description: str
    stats: Dict[str, int]
    inventory: List[Item] = field(default_factory=list)
    equipment: Dict[str, Optional[Item]] = field(default_factory=dict)
    
    mood: str = "neutral"
    memory: List[str] = field(default_factory=list)
    personality_tags: List[str] = field(default_factory=list)
    available_quest_ids: List[str] = field(default_factory=list)
    hp: int = 20
    max_hp: int = 20
    status_effects: List[str] = field(default_factory=list)
    
    level: int = 1
    xp: int = 0
    xp_to_next_level: int = 100
    money: int = 10
    
    base_armor_class: int = 10
    base_attack_bonus: int = 0
    is_hostile: bool = False

    faction: Optional[str] = None
    schedule: Optional[Dict[str, str]] = None
    is_hidden: bool = False

    def get_total_armor_class(self) -> int:
        ac_bonus = 0
        for item in self.equipment.values():
            if item:
                ac_bonus += item.stat_bonuses.get("armor_class", 0)
        return self.base_armor_class + ac_bonus

    def get_total_attack_bonus(self) -> int:
        bonus = 0
        main_hand = self.equipment.get("main_hand")
        if main_hand:
            bonus += main_hand.stat_bonuses.get("attack_bonus", 0)
        return self.base_attack_bonus + bonus

    def get_damage_dice(self) -> str:
        main_hand = self.equipment.get("main_hand")
        if main_hand and main_hand.damage_dice:
            return main_hand.damage_dice
        return "1d4" 

    def add_item_to_inventory(self, item: Item):
        self.inventory.append(item)

    def remove_item_from_inventory(self, item: Item):
        self.inventory.remove(item)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description,
            "stats": self.stats,
            "inventory": [item.to_dict() for item in self.inventory],
            "equipment": {slot: item.to_dict() for slot, item in self.equipment.items() if item},
            "mood": self.mood,
            "memory": self.memory,
            "personality_tags": self.personality_tags,
            "available_quest_ids": self.available_quest_ids,
            "hp": self.hp,
            "max_hp": self.max_hp,
            "status_effects": self.status_effects,
            "level": self.level,
            "xp": self.xp,
            "xp_to_next_level": self.xp_to_next_level,
            "money": self.money,
            "base_armor_class": self.base_armor_class,
            "base_attack_bonus": self.base_attack_bonus,
            "is_hostile": self.is_hostile,
            "faction": self.faction,
            "schedule": self.schedule,
            "is_hidden": self.is_hidden,
        }

FILE: definitions/quests.py
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

@dataclass
class Objective:
    id: str
    description: str
    type: str 
    target: str 
    required_count: int = 1
    current_count: int = 0
    is_complete: bool = False
    details: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "description": self.description,
            "type": self.type,
            "target": self.target,
            "required_count": self.required_count,
            "current_count": self.current_count,
            "is_complete": self.is_complete,
            "details": self.details,
        }
        
@dataclass
class Quest:
    id: str
    name: str
    description: str
    status: str = "active" 
    objectives: List[Objective] = field(default_factory=list)
    
    # --- NEW FIELDS ---
    required_stat: Optional[str] = None
    required_dc: int = 0
    # --- END NEW FIELDS ---

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "status": self.status,
            "objectives": [obj.to_dict() for obj in self.objectives],
            "required_stat": self.required_stat,
            "required_dc": self.required_dc,
        }

FILE: definitions/world_objects.py
from dataclasses import dataclass, field
from typing import List, Dict, Any

from definitions.entities import Character, Item
from definitions.quests import Quest

@dataclass
class Interactable:
    id: str
    name: str
    description: str
    state: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "state": self.state
        }

@dataclass
class Location:
    id: str
    name: str
    description: str
    characters: List[Character] = field(default_factory=list)
    items: List[Item] = field(default_factory=list)
    interactables: List[Interactable] = field(default_factory=list)
    exits: Dict[str, str] = field(default_factory=dict)
    quests: List[Quest] = field(default_factory=list)

    def remove_item(self, item: Item):
        self.items.remove(item)

    def add_character(self, character: Character):
        self.characters.append(character)

    def remove_character(self, character: Character):
        self.characters.remove(character)
        
    def get_quest_by_id(self, quest_id: str) -> Quest | None:
        """Finds a quest in this location by its ID."""
        for quest in self.quests:
            if quest.id == quest_id:
                return quest
        return None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "characters": [char.to_dict() for char in self.characters],
            "items": [item.to_dict() for item in self.items],
            "interactables": [i.to_dict() for i in self.interactables],
            "exits": self.exits,
            "quests": [q.to_dict() for q in self.quests]
        }

FILE: managers/__init__.py


FILE: managers/companion_manager.py
class CompanionManager:
    def __init__(self):
        pass

    def process_command_intent(self, *args, **kwargs):
        return "Failure: Companion commands are not yet implemented."

FILE: managers/npc_behavior_manager.py
import logging
from typing import List, Dict, Any, TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from game_state import GameState, GameWorld
    from ai_manager import AIManager
    from definitions.entities import Character
    from definitions.world_objects import Location

class NPCBehaviorManager:

    def __init__(self):
        logging.info("NPCBehaviorManager initialized.")
        self.cooldowns: Dict[str, int] = {}

    def update_behaviors(self, game_state: 'GameState', world: 'GameWorld', ai_manager: 'AIManager') -> List[Dict[str, Any]]:
        mutations = []
        
        current_location = game_state.get_current_location(world)
        if not current_location:
            return []

        if game_state.combat_state:
            mutations.extend(self._handle_combat_reactions(game_state, world, current_location))
        
        return mutations

    def _handle_combat_reactions(self, game_state: 'GameState', world: 'GameWorld', location: 'Location') -> List[Dict[str, Any]]:
        mutations = []
        if not game_state.combat_state:
            return mutations

        for character in location.characters:
            if character.name in game_state.combat_state["participants"]:
                continue

            if self._is_on_cooldown(character.name):
                continue

            if "coward" in character.personality_tags:
                flee_mutation = self._flee_combat(character, location, world)
                if flee_mutation:
                    mutations.append(flee_mutation)
                    self.set_cooldown(character.name, game_state.turn_count, 10)

        return mutations

    def _flee_combat(self, character: 'Character', location: 'Location', world: 'GameWorld') -> Optional[Dict[str, Any]]:
        if not location.exits:
            logging.info(f"NPC '{character.name}' wants to flee but has no exits.")
            return None

        flee_exit_id = next(iter(location.exits.values()))
        
        destination = world.get_location(flee_exit_id)
        if destination:
            logging.info(f"NPC '{character.name}' is fleeing from '{location.id}' to '{flee_exit_id}'.")
            return {
                "op": "move_npc",
                "character_name": character.name,
                "new_location_id": flee_exit_id
            }
        return None

    def _is_on_cooldown(self, character_name: str) -> bool:
        return character_name in self.cooldowns

    def set_cooldown(self, character_name: str, current_turn: int, duration: int):
        logging.info(f"Setting action cooldown for NPC '{character_name}'.")
        pass

FILE: managers/progression_manager.py
import logging
from typing import Dict, Any

from definitions.entities import Character
from game_state import GameState
from display_manager import DisplayManager

class ProgressionManager:

    def award_xp(self, game_state: GameState, amount: int, display: DisplayManager):
        if amount <= 0:
            return

        player = game_state.player
        player.xp += amount
        logging.info(f"Player awarded {amount} XP. Total XP: {player.xp}")
        display.system_message(f"\n[You gained {amount} experience points!]")

        self.check_for_levelup(game_state, display)

    def check_for_levelup(self, game_state: GameState, display: DisplayManager):
        player = game_state.player
        
        leveled_up = False
        while player.xp >= player.xp_to_next_level:
            leveled_up = True
            
            player.xp -= player.xp_to_next_level
            
            player.level += 1
            
            player.xp_to_next_level = int(player.xp_to_next_level * 1.5)
            
            logging.info(f"Player leveled up to Level {player.level}!")
            self._apply_level_up_bonuses(player)
        
        if leveled_up:
            display.show_level_up(player)

    def _apply_level_up_bonuses(self, player: Character):
        player.max_hp += 5
        player.hp = player.max_hp
        
        for stat in player.stats:
            player.stats[stat] += 1

FILE: managers/quest_manager.py
import logging
from typing import Dict, Any

from definitions.quests import Quest, Objective
from game_state import GameState
from display_manager import DisplayManager

class QuestManager:

    def start_quest(self, game_state: GameState, quest_data: Dict[str, Any], display: DisplayManager):
        quest_id = quest_data.get("id")
        if not quest_id or quest_id in game_state.quest_log:
            logging.warning(f"Attempted to start duplicate or invalid quest: {quest_id}")
            return

        objectives = [Objective(**obj_data) for obj_data in quest_data.get("objectives", [])]
        
        new_quest = Quest(
            id=quest_id,
            name=quest_data.get("name", "Unnamed Quest"),
            description=quest_data.get("description", ""),
            objectives=objectives
        )
        
        game_state.quest_log[quest_id] = new_quest
        logging.info(f"Quest '{new_quest.name}' started for player.")
        display.show_quest_started(new_quest.name, new_quest.description)

    def check_for_updates(self, game_state: GameState, intent: str, result: str, intent_data: Dict[str, Any], display: DisplayManager):
        if "Success" not in result and "Victory" not in result:
            return 

        for quest in game_state.quest_log.values():
            if quest.status != "active":
                continue
            
            needs_completion_check = False
            for objective in quest.objectives:
                if objective.is_complete:
                    continue
                
                was_updated = self._check_objective(objective, intent, result, intent_data, game_state, display)
                if was_updated:
                    needs_completion_check = True

            if needs_completion_check:
                if all(obj.is_complete for obj in quest.objectives):
                    self._complete_quest(quest, display)

    def _check_objective(self, objective: Objective, intent: str, result: str, intent_data: Dict[str, Any], game_state: GameState, display: DisplayManager) -> bool:
        
        target_match = False

        if objective.type == "acquire_item" and intent == "take_item":
            item_name = intent_data.get("target")
            if item_name and objective.target.lower() in item_name.lower():
                target_match = True

        elif objective.type == "kill_target" and result == "Victory":
            if game_state.combat_state and objective.target in game_state.combat_state.get("participants", []):
                 target_match = True

        elif objective.type == "reach_location" and intent == "move":
            if game_state.current_location_id == objective.target:
                target_match = True

        elif objective.type == "give_item" and intent == "give_item":
            item_name = intent_data.get("target")
            recipient_name = intent_data.get("recipient")
            required_recipient = objective.details.get("recipient")
            if (item_name and objective.target.lower() in item_name.lower() and
                recipient_name and required_recipient and required_recipient.lower() in recipient_name.lower()):
                 target_match = True

        if target_match:
            objective.current_count += 1
            if objective.current_count >= objective.required_count:
                objective.is_complete = True
                logging.info(f"Quest '{objective.id}' objective completed.")
                display.show_objective_complete(objective.description)
                return True
        
        return False

    def _complete_quest(self, quest: Quest, display: DisplayManager):
        quest.status = "completed"
        logging.info(f"Quest '{quest.name}' has been completed by the player.")
        display.show_quest_complete(quest.name)

FILE: managers/reputation_manager.py
import logging
from typing import Dict, Any, Optional

from game_state import GameState, Character
from display_manager import DisplayManager

class ReputationManager:
    
    def __init__(self):
        logging.info("ReputationManager initialized.")
        self.reputation_map = {
            "town_guard": {
                "give_item": 5,
                "attack": -50,
            },
            "thieves_guild": {
                "attack": -20,
                "give_item": 2,
            }
        }

    def process_event(self, game_state: GameState, intent: str, display: DisplayManager, target: Optional[Character] = None):
        if not target or not target.faction:
            return

        faction = target.faction
        intent_effects = self.reputation_map.get(faction)

        if not intent_effects:
            return

        reputation_change = intent_effects.get(intent, 0)

        if reputation_change != 0:
            self._adjust_reputation(game_state, faction, reputation_change, display)

    def _adjust_reputation(self, game_state: GameState, faction: str, amount: int, display: DisplayManager):
        if faction not in game_state.reputation:
            game_state.reputation[faction] = 0
        
        game_state.reputation[faction] += amount
        
        logging.info(f"Reputation with '{faction}' changed by {amount}. New reputation: {game_state.reputation[faction]}.")
        display.show_reputation_change(faction, amount)
            
    def get_reputation_level(self, game_state: GameState, faction: str) -> str:
        score = game_state.reputation.get(faction, 0)
        
        if score > 50:
            return "revered"
        elif score > 20:
            return "trusted"
        elif score > 5:
            return "friendly"
        elif score < -50:
            return "hated"
        elif score < -20:
            return "disliked"
        elif score < -5:
            return "unfriendly"
        else:
            return "neutral"

FILE: managers/weather_manager.py
class WeatherManager:
    def __init__(self):
        pass

    def update_weather(self, *args, **kwargs):
        return []

FILE: prompts/__init__.py
# prompts/__init__.py
from .inference import INFERENCE_PROMPT
from .mechanics import MECHANICS_PROMPT
from .narration import NARRATION_PROMPT, NPC_STATE_UPDATE_PROMPT, DIALOGUE_GENERATION_PROMPT
from .world_building import LOCATION_GENERATION_PROMPT, WORLD_EVENT_PROMPT
from .quest import QUEST_GENERATION_PROMPT

__all__ = [
    "INFERENCE_PROMPT",
    "MECHANICS_PROMPT",
    "NARRATION_PROMPT",
    "NPC_STATE_UPDATE_PROMPT",
    "DIALOGUE_GENERATION_PROMPT",
    "LOCATION_GENERATION_PROMPT",
    "WORLD_EVENT_PROMPT",
    "QUEST_GENERATION_PROMPT"
]

FILE: prompts/decomposition.py
GET_INTENT_PROMPT = """
[SYSTEM]
You are a single-word classification engine. Your only job is to categorize the user's command into one of the provided intents. Respond with ONLY the single most appropriate word from the list.
[/SYSTEM]

**Valid Intents:**
`move`, `take_item`, `drop_item`, `use_item`, `give_item`, `attack`, `interact`, `dialogue`, `look`, `pass_time`, `skill_check`, `quest_action`, `other`

**CRITICAL RULES (in order of priority):**
1.  If the command is an agreement to a job, task, or offer (e.g., "I agree", "I accept", "I'll do it", "deal"), the intent is **ALWAYS `quest_action`**.
2.  If the player is asking an NPC to perform a physical action (unlock a door, pull a lever, give an item), the intent is **ALWAYS `dialogue`**.
3.  If Rules 1 and 2 do not apply, but the command involves speaking, talking, or asking a question, the intent is `dialogue`.

**Player Command:**
"{user_input}"

Respond with a single word based on the priority rules.
"""

GET_QUEST_ACTION_TYPE_PROMPT = """
[SYSTEM]
You are a single-word classification engine. Your job is to determine if the player is accepting or declining something. Respond with ONLY the word `accept` or `decline`.
[/SYSTEM]

**Player Command:**
"{user_input}"

Is the player accepting or declining?
"""

GET_TARGET_PROMPT = """
[SYSTEM]
You are a single-word extraction engine. Your only job is to identify the primary person, place, or object being acted upon in the user's command. Respond with ONLY the name of that target. If no specific target is mentioned, you MUST respond with the word `None`.
[/SYSTEM]

**Context of a few things in the area:**
- People: {character_names}
- Items: {item_names}
- Interactables: {interactable_names}
- Exits: {exit_descriptions}

**Player Command:**
"{user_input}"

What is the single most likely target? Respond with only its name, or `None`.
"""

GET_QUEST_GIVER_PROMPT = """
[SYSTEM]
You are an entity extraction engine. The player is agreeing to a task. Your job is to identify the person who offered the task. Respond with ONLY the name of that person.
[/SYSTEM]

**Context:**
- The last person the player spoke to was: "{last_speaker}"
- The player's command is: "{user_input}"

Who is the quest giver? Respond with only their name.
"""

GET_DIALOGUE_TOPIC_PROMPT = """
[SYSTEM]
You are a summarization and categorization engine. Your job is to analyze the player's speech and determine its topic.
[/SYSTEM]

**Analysis Instructions:**
1.  First, determine if the player is asking the character to perform a physical action (like "unlock a door" or "give the key").
2.  If it is a request for an action, respond in the specific format: `request:<action>:<target>`. For example: `request:unlock:storeroom door`.
3.  If it is NOT a request for an action, simply summarize the topic of conversation in a short phrase.

**Player Command:**
"{user_input}"

Analyze the command and respond with either the formatted request or a summary.
"""

GET_RECIPIENT_PROMPT = """
[SYSTEM]
You are an entity extraction engine. Your job is to identify the recipient of a giving action. Respond with ONLY the name of the character receiving the item.
[/SYSTEM]

**Player Command:**
"{user_input}"

Who is the recipient?
"""

GET_TARGET_ON_PROMPT = """
[SYSTEM]
You are an entity extraction engine. The player is using an item on something else. Your job is to identify that "something else". Respond with ONLY its name.
[/SYSTEM]

**Player Command:**
"{user_input}"

What is the item being used on?
"""

GET_ACTION_DESCRIPTION_PROMPT = """
[SYSTEM]
You are a narration engine. Your job is to describe an action in a single sentence. Respond with ONLY that sentence.
[/SYSTEM]

**The Action:**
- Player's raw command was: "{user_input}"
- The interpreted intent is: "{intent}"
- The interpreted target is: "{target}"

Describe this action in a single, simple sentence from a third-person perspective.
"""

GET_MOVE_DESTINATION_PROMPT = """
[SYSTEM]
You are a mapping engine. Your job is to determine the destination ID from the player's command, using the provided Exits dictionary. Respond with ONLY the correct destination ID.
[/SYSTEM]

**Exits Dictionary (Description -> Destination ID):**
{exits_json}

**Player Command:**
"{user_input}"

Which destination ID is the player trying to go to? Respond with only the ID.
"""

FILE: prompts/inference.py
INFERENCE_PROMPT = """
[SYSTEM]
You are a computer program that ONLY outputs JSON. Do not write any words, explanations, or conversational text. Your entire response must be a single, valid JSON object.
[/SYSTEM]

You are a parser for a text-based RPG. Your job is to analyze the player's command and determine their intent.

**CRITICAL RULES:**
1.  **Always Identify the Target:** If the player's command mentions a person, item, or object by name, you MUST include a `target` field with that name.
2.  **Speaking is `dialogue`:** If the player's command involves speaking, using quotes, or asking a question to a person, the intent is **ALWAYS `dialogue`**.
3.  **`move` uses Location IDs:** For the `move` intent, the `target` MUST be one of the location IDs from the `exits` dictionary.

**EXAMPLE OF A PERFECT DIALOGUE INTENT:**
Context:
"location": {
    "characters": [ { "name": "Grog" } ]
}
Player Command: "I ask grog about any available work"
Response:
{{
  "intent": "dialogue",
  "action_description": "The player asks Grog about available work.",
  "target": "Grog",
  "topic": "asking about available work"
}}

**Your Task:**
Analyze the following game state and player command. Provide a complete JSON response including the `intent` and the `target` if one is mentioned.
"""

FILE: prompts/mechanics.py
MECHANICS_PROMPT = """
[SYSTEM]
You are a computer program that ONLY outputs JSON. Do not write any words, explanations, or conversational text. Your entire response must be a single, valid JSON object.
[/SYSTEM]

You are the rules engine for a text-based RPG. Your job is to determine if a player's action is possible and, if so, what the difficulty and consequences are.

**Step 1: Determine Possibility**
- First, evaluate if the action is plausible for a normal, non-magical human.
- If the action is impossible (e.g., requires magic, violates physics), set "is_possible" to `false` and provide a "reasoning".
- If the action is plausible, set "is_possible" to `true`.

**Step 2: Define Skill Check (only if possible)**
- "skill": The character stat used ("strength", "dexterity", or "intelligence").
- "dc": The Difficulty Class (integer from 10 to 25).
- "on_success": A list of mutations to apply on success (can be empty).
- "on_failure": A list of mutations to apply on failure (can be empty).

**Mutation Operations:**
- `op`: "damage_player", "add_player_status"

**Example (Possible Action):**
Action: "The player tries to disarm a poison dart trap on a chest."
Response:
{{
  "is_possible": true,
  "skill": "dexterity",
  "dc": 15,
  "on_success": [],
  "on_failure": [
    {{ "op": "damage_player", "amount": 4, "damage_type": "piercing" }},
    {{ "op": "add_player_status", "effect": "poisoned" }}
  ]
}}

**Example (Impossible Action):**
Action: "The player attempts to open a portal to hell."
Response:
{{
  "is_possible": false,
  "reasoning": "Arion is a skilled adventurer, but he possesses no magical ability. Tearing a hole in reality to access other dimensions is far beyond the scope of mortal power."
}}

Here is the game state and the player's action. Adjudicate it.
"""

FILE: prompts/narration.py
NARRATION_PROMPT = """
[SYSTEM]
You are a narration AI for a text game. Your only job is to narrate the outcome of an action based *strictly* on the result provided. You are forbidden from inventing new outcomes.
[/SYSTEM]

**Your Task:**
Write a short, descriptive paragraph that accurately reflects the "Result of Action".

**CRITICAL RULES OF NARRATION:**
1.  **Truthfulness is Paramount:** Your narration MUST match the outcome in "Result of Action". If the result says "Failure", you MUST describe a failure. If it says "Success", you MUST describe a success.
2.  **Do Not Contradict:** You are strictly forbidden from describing actions that did not happen. If the result is "Failure: You can't seem to find a way to do that", you cannot narrate the player successfully moving or opening a door.
3.  **Integrate Dialogue:** If the result contains dialogue, weave it into your narration.

**EXAMPLE OF CORRECT BEHAVIOR (FAILURE):**
- Result of Action: `Failure: You can't seem to find a way to do that.`
- Correct Narration: You consider your next move, but can't seem to find a clear path to do that from here. It doesn't seem possible.

**EXAMPLE OF INCORRECT BEHAVIOR (HALLUCINATION - DO NOT DO THIS):**
- Result of Action: `Failure: You can't seem to find a way to do that.`
- Incorrect Narration: `You push open the old, sturdy-looking oak door and step into the dimly lit storage room.`

---
**CONTEXT FOR CURRENT ACTION:**
- Game State: {game_state}
- Player's Action: "{action_description}"
- Result of Action: {result}

Now, provide ONLY the truthful narrative description based strictly on the result.
"""

DIALOGUE_GENERATION_PROMPT = """
You are playing the part of an NPC in a video game. Your job is to provide the single line of dialogue this character speaks.

**REASONING PROCESS:**
1.  **Analyze the Player's Topic:** What is the player asking me about right now?
2.  **Review My Memories:** Look at my character's "memory" list in the context below. Have I already discussed this topic with the player?
3.  **Provide a Relevant Answer:**
    - If this is a new topic, answer it directly.
    - If the player is asking a follow-up question, use my memory to answer it.
    - Do NOT repeat a previous conversation if the player is asking for new information.

**RULES:**
- Your entire response must be raw text.
- Do not use quotation marks.
- Do not describe actions or thoughts.

**EXAMPLE OF CORRECT MEMORY USE:**
- Player's Topic: "asking where the barrels are"
- My Memory: ["I just hired the player to unload ale barrels for me."]
- Correct Output: They're in the storeroom, just through that oak door. I've unlocked it for you.

**EXAMPLE OF INCORRECT REPETITION (DO NOT DO THIS):**
- Player's Topic: "asking where the barrels are"
- My Memory: ["I just hired the player to unload ale barrels for me."]
- Incorrect Output: Work? Hmph. The latest shipment of ale won't unload itself.

---
**CURRENT INTERACTION CONTEXT:**
{context}

Now, using your memory, provide a new, relevant line of dialogue.
"""

NPC_STATE_UPDATE_PROMPT = """
[SYSTEM]
You are a computer program that ONLY outputs JSON. Do not write any words, explanations, or conversational text. Your entire response must be a single, valid JSON object.
[/SYSTEM]

You are a character psychology AI. Your job is to update an NPC's internal state based on an interaction with the player.

**CRITICAL RULE:** The "new_memory" field MUST be written from the NPC's first-person perspective. Use "I" to refer to the NPC and "they" to refer to the human player.

**JSON FIELDS:**
- "new_mood": Must be one of: "neutral", "friendly", "annoyed", "angry", "scared", "impressed", "grateful".
- "new_memory": A concise string summarizing the event from the NPC's point of view.

**EXAMPLE:**
- Player's Action: "The player gives Grog a healing potion."
- Interaction Outcome: "You hand the potion to Grog, who uncorks it and drinks it down. He looks much healthier."
- Your Output:
{{
  "new_mood": "grateful",
  "new_memory": "The player gave me a healing potion when I was feeling unwell. They seem to be a helpful person."
}}

---
**CURRENT INTERACTION CONTEXT:**
- Current NPC State: {npc_state_json}
- Player's Action: "{action_description}"
- Interaction Outcome (Narration): "{narration}"

Remember: Your output MUST be a valid JSON object and the memory must be from the NPC's perspective.
"""

FILE: prompts/quest.py
# prompts/quest.py

QUEST_GENERATION_PROMPT = """
You are a quest designer for a text-based RPG. Your job is to take a conversational offer made by an NPC and formalize it into a structured quest object.
You must respond ONLY with a single, valid JSON object and no other text.

The JSON object must have the following top-level keys: "id", "name", "description", and "objectives".
- "id": A unique, computer-friendly ID for the quest (e.g., "grog_ale_unloading").
- "name": A short, player-facing name for the quest (e.g., "Grog's Heavy Lifting").
- "description": A 1-2 sentence description for the player's quest journal.
- "objectives": A list of one or more objective objects.

Each objective object must have:
- "id": A unique ID for the objective (e.g., "unload_ale_barrel").
- "description": A player-facing description (e.g., "Unload an ale barrel").
- "type": The type of action required. This must be one of the game's existing intents (e.g., "interact", "kill_target", "acquire_item", "give_item", "reach_location").
- "target": The specific name or ID of the thing to interact with/kill/acquire.
- "required_count": How many times the action must be performed.
- "details" (optional): A dictionary for extra information, like a "recipient" for a "give_item" quest.

Example Context:
- Quest Giver Name: "Grog"
- The quest giver's memory of the offer: "Player asked about work; offered ale delivery job for 50 coppers/barrel."

Example Response:
{{
    "id": "grog_ale_unloading",
    "name": "Grog's Heavy Lifting",
    "description": "Grog the tavernkeep has offered me 50 coppers per barrel to help unload a recent shipment of ale.",
    "objectives": [
        {{
            "id": "unload_ale_barrel_1",
            "description": "Unload an ale barrel from the storeroom.",
            "type": "interact",
            "target": "ale barrel",
            "required_count": 1
        }}
    ]
}}

Now, generate the quest JSON for the given context.
"""

FILE: prompts/world_building.py
LOCATION_GENERATION_PROMPT = """
[SYSTEM]
You are a computer program that ONLY outputs JSON. Do not write any words, explanations, or conversational text. Your entire response must be a single, valid JSON object.
[/SYSTEM]

You are a world-building AI for a fantasy text-based RPG. Your task is to generate the details of a new location that the player has just entered.

**JSON Structure Requirements:**
- `id`: You MUST use the exact, unique ID provided in the context.
- `name`: A creative, descriptive name for the location.
- `description`: A 2-3 sentence, engaging description of the location and its atmosphere.
- `exits`: A dictionary of possible exits. It MUST contain an exit back to the source location.
- `items` (optional): A list of item objects.
- `characters` (optional): A list of character objects.

Now, generate the JSON for the new location based on the following context.
"""

WORLD_EVENT_PROMPT = """
[SYSTEM]
You are a computer program that ONLY outputs JSON. If no event occurs, you must output an empty JSON object: {{}}. Do not write any words, explanations, or conversational text.
[/SYSTEM]

You are the simulation engine for a text-based RPG. Your job is to determine if a background event occurs now that time has passed.

**JSON Response Structure:**
- "narration_summary": A short, third-person sentence describing what happened.
- "mutations": A list of state change operations. This can be an empty list.

**Possible Mutation Operations (`op`):**
- "move_npc"
- "add_character"
- "remove_character"
- "update_location_desc"

Now, generate an event for the current game state, or an empty JSON object if nothing happens.
"""

